{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Intelig\u00eancia Artificial","text":""},{"location":"#sobre-o-portfolio","title":"\ud83d\udd0e Sobre o portfolio","text":"<pre><code>Este projeto \u00e9 um estudo sobre os assuntos de intelig\u00eancia artificial,\nministrado como uma disciplina na Universidade de Bras\u00edlia.\n</code></pre>"},{"location":"#comentarios","title":"Coment\u00e1rios","text":"<p>Irei deixar coment\u00e1rios sobre cada sess\u00e3o utilizando o seguinte formato:</p> <p>Este \u00e9 um texto sobre um ponto adicional do qual eu gostaria de adicionar sobre o assunto descrito acima; Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nullam euismod, nisl sed lacinia ultricies, nunc nisl.</p>"},{"location":"#topicos","title":"T\u00f3picos","text":"<ul> <li>Entrega 1<ul> <li>O que \u00e9 Intelig\u00eancia Artificial?</li> <li>Hist\u00f3ria da Intelig\u00eancia Artificial</li> <li>Estado da Arte</li> <li>Agentes</li> </ul> </li> <li>Entrega 2 (Resolvendo problemas por Busca)<ul> <li>Agentes de Solu\u00e7\u00f5es de Problemas</li> <li>Algoritmos de Busca</li> <li>Fun\u00e7\u00f5es Heur\u00edsticas</li> <li>Busca em ambientes complexos</li> <li>Algoritmos gen\u00e9ticos</li> <li>Discuss\u00f5es</li> <li>Projetos e problemas</li> </ul> </li> </ul>"},{"location":"agent/","title":"Agentes e ambientes","text":"<p>Quando criamos um programa que possui algum n\u00edvel de intelig\u00eancia artificial precisamos que ele tome decis\u00f5es baseadas em algum ambiente. No caso, esse programa acaba se tornando um agente, por tormar a\u00e7\u00f5es/decis\u00f5es.</p>"},{"location":"agent/#tipos-de-agentes","title":"Tipos de agentes","text":"<p>No assunto que estamos abordando, temos dois tipos de agentes:</p> <ul> <li>Agente Inteligente</li> <li>Agente Racional</li> </ul>"},{"location":"agent/#agente-inteligente","title":"Agente Inteligente","text":"<p>Das caracter\u00edsticas que formam um agente inteligente:</p> <p>\u00c9 esperado que um agente ineligente seja aut\u00f4nomo quanto suas decis\u00f5es, ou seja, ele deve ser capaz de tomar decis\u00f5es sem a interven\u00e7\u00e3o humana.</p> <p>\u00c9 necess\u00e1rio que ele consiga perceber o ambiente em que est\u00e1 atuando e que consiga tomar decis\u00f5es baseadas nessa percep\u00e7\u00e3o.</p> <p>Persista por um per\u00edodo de tempo prolongado, para que consiga aprender e reter esse conhecimento para tomar decis\u00f5es futuras. Quanto mais conhecimento \u00fatil um agente possui, mais inteligente ele \u00e9, desde que tenha distin\u00e7\u00e3o se o conhecimento \u00e9 obsoleto ou n\u00e3o, ou se o conhecimento est\u00e1 errado de alguma forma.</p> <p>Tamb\u00e9m \u00e9 esperado que esse agente adapte-se a mudan\u00e7as no ambiente. Combinando as caracter\u00edsticas descritas acima, o agente consegue mudar seu comportamento para se adaptar a mudan\u00e7as no ambiente e melhorar seu resultado.</p> <p>Um agente inteligente tamb\u00e9m deve ser capaz de criar e buscar objetivos, ou seja, ele deve ser capaz de definir o que \u00e9 um objetivo e como alcan\u00e7\u00e1-lo.</p> <p>Esse \u00faltimo ponto sobre criar e buscar objetivos \u00e9 algo que me chama aten\u00e7\u00e3o, pois n\u00e3o \u00e9 algo totalmente aut\u00eantico em intelig\u00eancias artificiais, visto que n\u00f3s humanos possuimos objetivos que s\u00e3o definidos por n\u00f3s mesmos, no caso, por desejo pr\u00f3rio. J\u00e1 uma intelig\u00eancia artificial, por mais que seja capaz de definir objetivos, esses objetivos s\u00e3o definidos por um humano, ou seja, n\u00e3o \u00e9 algo aut\u00eantico.</p> <p>Tamb\u00e9m \u00e9 question\u00e1vel se em algum momento na hist\u00f3ria uma intelig\u00eancia conseguir\u00e1 criar desejos pr\u00f3prios, de forma totalmente aut\u00eantica.</p>"},{"location":"agent/#agente-racional","title":"Agente Racional","text":"<p>O agente racional tem como objetivo atingir resultados \u00f3timos, ou se imposs\u00edvel de obter um resultado \u00f3timo devido a limita\u00e7\u00f5es, ele busca obter um resultado o mais pr\u00f3ximo poss\u00edvel do melhor resultado. Essa forma de buscar um resultado \u00e9 baseada na racionalidade.</p>"},{"location":"agent/#racionalidade","title":"Racionalidade","text":"<p>A racionalidade de m\u00e1quinas \u00e9 um padr\u00e3o matem\u00e1ticamente definido pois usa a l\u00f3gica para tomar decis\u00f5es, e a l\u00f3gica por si s\u00f3 \u00e9 matem\u00e1tica. A abordagem de racionalidade \u00e9 mais suscet\u00edvel ao desenvolvimento cient\u00edfico pois n\u00e3o leva em conta cren\u00e7as e pseudo-ci\u00eancias humanas, e sim resultados comprovados sobre o objetivo alcan\u00e7ado.</p> <p>Devido \u00e0 abordagem comum para se desenvolver uma intelig\u00eancia artificial ser a racionalidade, \u00e9 comum, mas n\u00e3o exclusivo, que as intelig\u00eancias artificiais busquem reproduzir o comportamento mais l\u00f3gico poss\u00edvel, e n\u00e3o o comportamento mais humano poss\u00edvel. Por ser mais comum, essa abordagem constitui o Modelo Padr\u00e3o de intelig\u00eancia artificial.</p>"},{"location":"agent/#consequencialismo-e-medida-de-performance","title":"Consequencialismo e Medida de Performance","text":"<p>Um agente racional ir\u00e1 tomar decis\u00f5es baseadas em consequ\u00eancias, ou seja, buscar boas consequ\u00eancias ao inv\u00e9s das m\u00e1s consequ\u00eancias. Para isso, \u00e9 necess\u00e1rio que o agente seja capaz de medir a performance de suas a\u00e7\u00f5es, para que possa tomar decis\u00f5es baseadas nessa medida. Essa medida de performance \u00e9 chamada de fun\u00e7\u00e3o de utilidade, e isso \u00e9 inserido no programa pelo programador, de forma explicita ou implicita. Por exemplo, um programa que joga xadr\u00eaz pode ter como fun\u00e7\u00e3o de utilidade o n\u00famero de pe\u00e7as que ele possui no tabuleiro.</p> <p>Em meus estudos de aprendizado de m\u00e1quina, conheci essa fun\u00e7\u00e3o de utilidade  como o c\u00e1lculo do gradiente estoc\u00e1stico descendente, que \u00e9 uma forma de medir o qu\u00e3o bom \u00e9 o resultado de uma a\u00e7\u00e3o para que em seguida o agente tome decis\u00f5es a fim de achar um resultado \u00f3timo local esperando que fosse o resultado \u00f3timo global.</p>"},{"location":"agent/#especificando-o-ambiente-de-tarefas","title":"Especificando o ambiente de tarefas","text":"<p>Essa parte trata de projetar um agente racional especificando o ambiente trabalhado da forma mais completa poss\u00edvel. Para isso, podemos utilizar a descri\u00e7\u00e3o PEAS (Performance, Environment, Actuators, Sensors).</p>"},{"location":"agent/#peas","title":"PEAS","text":""},{"location":"agent/#performance","title":"Performance","text":"<p>Define a medida de performance desejada.</p>"},{"location":"agent/#environment","title":"Environment","text":"<p>Define o ambiente em que o agente ir\u00e1 atuar.</p>"},{"location":"agent/#actuators","title":"Actuators","text":"<p>Define as a\u00e7\u00f5es que o agente pode tomar.</p>"},{"location":"agent/#sensors","title":"Sensors","text":"<p>Define como o agente ir\u00e1 perceber o ambiente.</p> <p>Por exemplo, se o agente for um carro aut\u00f4nomo, a medida de performance pode ser a dist\u00e2ncia percorrida, a velocidade atingida, o n\u00edvel de seguran\u00e7a, e o consumo de gasolina. O ambiente pode ser uma pista de corrida, pedestres, outros carros e o clima. Quanto aos atuadores podem ser o volante, acelerador, marcha, freio e buzina. J\u00e1 os sensores podem ser c\u00e2meras, sensores de dist\u00e2ncia e um GPS.</p>"},{"location":"agent/#arquitetura-do-agente","title":"Arquitetura do Agente","text":"<p>A arquitetura do agente \u00e9 composta de um computador que possui sensores e atuadores.</p>"},{"location":"agent/#tipos-de-agente","title":"Tipos de Agente","text":""},{"location":"agent/#representacao-de-estados","title":"Representa\u00e7\u00e3o de Estados","text":"<p>A representa\u00e7\u00e3o Atomica \u00e9 a mais simples, onde cada estado \u00e9 representado por um \u00fanico valor onde estados s\u00e3o descritos com um \u00fanico valor at\u00f4mico, ou seja, n\u00e3o decompon\u00edvel. Quando falamos da representa\u00e7\u00e3o Fatorada, falamos que um estado pode possuir atributos que fazem parte desse estado, por exemplo, um estado pode ser representado por um conjunto de atributos como posi\u00e7\u00e3o, velocidade e dire\u00e7\u00e3o. J\u00e1 a representa\u00e7\u00e3o Estruturada, \u00e9 uma representa\u00e7\u00e3o mais complexa pois n\u00e3o possui apenas atributos, como tamb\u00e9m pode possuir objetos e esses objetos podem possuir rela\u00e7\u00f5es entre si.</p> <p>Em quest\u00e3o de complexidade, podemos dizer que a representa\u00e7\u00e3o atomica \u00e9 mais simples enquanto a representa\u00e7\u00e3o estruturada \u00e9 mais complexa e mais expressiva.</p> <pre><code>graph LR\n    A[Representa\u00e7\u00e3o Atomica] --&gt; B[Representa\u00e7\u00e3o Fatorada] --&gt; C[Representa\u00e7\u00e3o Estruturada]</code></pre>"},{"location":"complex_environments/","title":"Complex environments","text":""},{"location":"complex_environments/#busca-em-ambientes-complexos","title":"Busca em Ambientes Complexos","text":""},{"location":"complex_environments/#definicao-do-problema","title":"Defini\u00e7\u00e3o do Problema","text":"<p>A busca em ambientes complexos \u00e9 uma sub\u00e1rea cr\u00edtica da intelig\u00eancia artificial  (IA), cuja relev\u00e2ncia abrange desde simula\u00e7\u00f5es computacionais at\u00e9 sistemas de  otimiza\u00e7\u00e3o em tempo real. Diversas caracter\u00edsticas distinguem um ambiente  complexo, incluindo um grande espa\u00e7o de estados, incerteza nas vari\u00e1veis de  entrada, din\u00e2mica temporal e multifatorialidade nos objetivos.</p>"},{"location":"complex_environments/#caracteristicas-dos-ambientes-complexos","title":"Caracter\u00edsticas dos Ambientes Complexos","text":"<ol> <li> <p>Grande Espa\u00e7o de Estados: O conjunto de todas as configura\u00e7\u00f5es poss\u00edveis \u00e9 significativo, tornando invi\u00e1vel a busca exaustiva.</p> </li> <li> <p>Incerteza: Falta de informa\u00e7\u00f5es precisas sobre estados e transi\u00e7\u00f5es.</p> </li> <li> <p>Din\u00e2mica Temporal: O sistema ou ambiente pode mudar autonomamente com o tempo.</p> </li> <li> <p>Custo Computacional: A avalia\u00e7\u00e3o de um estado pode envolver c\u00e1lculos complexos.</p> </li> <li> <p>Multifatorialidade: M\u00faltiplos objetivos podem estar em jogo, muitas vezes conflitando entre si.</p> </li> </ol>"},{"location":"complex_environments/#tecnicas-de-busca-em-engenharia-de-software","title":"T\u00e9cnicas de Busca em Engenharia de Software","text":"<ul> <li> <p>Busca Informada: Emprega-se uma fun\u00e7\u00e3o heur\u00edstica para estimar o custo de um caminho do estado atual ao objetivo. O algoritmo A* \u00e9 frequentemente usado em tais cen\u00e1rios.</p> </li> <li> <p>Heur\u00edsticas Adaptativas: Em sistemas din\u00e2micos, as heur\u00edsticas podem ser ajustadas em tempo real para se adaptar \u00e0s novas condi\u00e7\u00f5es.</p> </li> <li> <p>Busca Local: Algoritmos como o gradiente descendente s\u00e3o usados para otimiza\u00e7\u00f5es localizadas e s\u00e3o particularmente \u00fateis quando o espa\u00e7o de busca \u00e9 cont\u00ednuo.</p> </li> <li> <p>Busca em \u00c1rvore: T\u00e9cnicas como o Monte Carlo Tree Search (MCTS) s\u00e3o \u00fateis para explorar espa\u00e7os de estados grandes de forma estruturada.</p> </li> <li> <p>Busca com Incerteza: Utiliza-se de m\u00e9todos estoc\u00e1sticos e teoria das decis\u00f5es para gerar estrat\u00e9gias \u00f3timas ou sub-\u00f3timas sob incerteza.</p> </li> </ul>"},{"location":"complex_environments/#desafios-e-implicacoes-para-a-engenharia-de-software","title":"Desafios e Implica\u00e7\u00f5es para a Engenharia de Software","text":"<ol> <li> <p>Explos\u00e3o Combinat\u00f3ria: O aumento exponencial do espa\u00e7o de estados exige t\u00e9cnicas de poda e paralelismo para melhorar a efici\u00eancia.</p> </li> <li> <p>Planejamento sob Incerteza: Incorporar modelos de incerteza para otimiza\u00e7\u00e3o de decis\u00f5es requer abordagens como programa\u00e7\u00e3o din\u00e2mica estoc\u00e1stica.</p> </li> <li> <p>Otimiza\u00e7\u00e3o em Tempo Real: O tempo de execu\u00e7\u00e3o \u00e9 uma restri\u00e7\u00e3o cr\u00edtica, necessitando de algoritmos de busca que possam fornecer solu\u00e7\u00f5es em um tempo vi\u00e1vel.</p> </li> <li> <p>Conflito de Objetivos: T\u00e9cnicas de otimiza\u00e7\u00e3o multiobjetivo, como Pareto Front, s\u00e3o necess\u00e1rias para resolver problemas com m\u00faltiplos objetivos conflitantes.</p> </li> </ol>"},{"location":"complex_environments/#conclusao","title":"Conclus\u00e3o","text":"<p>A busca em ambientes complexos \u00e9 uma \u00e1rea em r\u00e1pido desenvolvimento com  implica\u00e7\u00f5es diretas na engenharia de software. O dom\u00ednio apresenta desafios  \u00fanicos em termos de efici\u00eancia computacional, qualidade da solu\u00e7\u00e3o e  adaptabilidade a ambientes din\u00e2micos e incertos. O sucesso na solu\u00e7\u00e3o desses  problemas envolve a aplica\u00e7\u00e3o integrada de v\u00e1rias estrat\u00e9gias de busca,  cada uma com suas pr\u00f3prias vantagens, limita\u00e7\u00f5es e custos computacionais  associados.</p>"},{"location":"complex_environments/#bibliografia","title":"Bibliografia","text":"<p>https://edisciplinas.usp.br/pluginfile.php/7340740/mod_resource/content/1/IAPos_NA06.pdf</p> <p>https://edisciplinas.usp.br/pluginfile.php/4848799/mod_resource/content/3/2019-ProblemasComoBusca-BuscaCega.pdf</p> <p>https://edisciplinas.usp.br/pluginfile.php/4183182/mod_resource/content/1/Aula1V2017.pdf</p>"},{"location":"heuristics/","title":"Heuristics","text":""},{"location":"heuristics/#o-que-sao-funcoes-heuristicas","title":"O que s\u00e3o Fun\u00e7\u00f5es Heur\u00edsticas?","text":"<p>Em termos simples, uma fun\u00e7\u00e3o heur\u00edstica \u00e9 como um atalho que ajuda o  computador a decidir qual op\u00e7\u00e3o \u00e9 \"provavelmente\" a melhor, sem ter que  calcular todas as op\u00e7\u00f5es em detalhes. Ela d\u00e1 uma esp\u00e9cie de \"nota\" para cada  op\u00e7\u00e3o, e a op\u00e7\u00e3o com a melhor \"nota\" \u00e9 geralmente escolhida.</p> <p>Imagine que voc\u00ea est\u00e1 jogando um jogo de tabuleiro e tem v\u00e1rias jogadas  poss\u00edveis. Voc\u00ea n\u00e3o tem tempo para pensar em todas as consequ\u00eancias de cada  movimento at\u00e9 o final do jogo, certo? Em vez disso, voc\u00ea faz um \"palpite  educado\" sobre qual movimento parece ser o melhor. Esse \"palpite educado\"  \u00e9 essencialmente o que uma fun\u00e7\u00e3o heur\u00edstica faz em  intelig\u00eancia artificial (IA).</p>"},{"location":"heuristics/#importancia","title":"Import\u00e2ncia","text":"<p>Fun\u00e7\u00f5es heur\u00edsticas s\u00e3o importantes porque tornam os algoritmos mais r\u00e1pidos.  Em muitos problemas, especialmente em IA, h\u00e1 muitas op\u00e7\u00f5es e possibilidades a  considerar. Calcular todas elas levaria muito tempo e recursos. Uma boa fun\u00e7\u00e3o  heur\u00edstica pode reduzir drasticamente esse esfor\u00e7o.</p>"},{"location":"heuristics/#exemplos-simples","title":"Exemplos Simples","text":"<ol> <li> <p>Jogo da Velha: Uma heur\u00edstica simples seria contar o n\u00famero de linhas,  colunas ou diagonais que est\u00e3o a um passo de serem completadas. Quanto mais  voc\u00ea tiver, melhor \u00e9 a posi\u00e7\u00e3o.</p> </li> <li> <p>Problema do Caminho Mais Curto: Se voc\u00ea quiser ir de uma cidade A para  uma cidade B, uma fun\u00e7\u00e3o heur\u00edstica pode ser a dist\u00e2ncia em linha reta entre A  e B. Essa \u00e9 uma boa estimativa do caminho mais curto poss\u00edvel.</p> </li> </ol>"},{"location":"heuristics/#como-sao-utilizadas","title":"Como s\u00e3o Utilizadas?","text":"<p>Em algoritmos como A* (A-star), as fun\u00e7\u00f5es heur\u00edsticas s\u00e3o usadas para  estimar o custo do caminho mais curto de um ponto a outro. O algoritmo usa  essa estimativa para priorizar quais caminhos explorar primeiro.</p>"},{"location":"heuristics/#limitacoes","title":"Limita\u00e7\u00f5es","text":"<ol> <li> <p>Precis\u00e3o: Uma fun\u00e7\u00e3o heur\u00edstica \u00e9 um palpite, ent\u00e3o pode estar errada.  Uma m\u00e1 heur\u00edstica pode at\u00e9 piorar o desempenho do algoritmo.</p> </li> <li> <p>Complexidade: Algumas fun\u00e7\u00f5es heur\u00edsticas podem ser complicadas de  calcular, anulando os benef\u00edcios de velocidade que oferecem.</p> </li> </ol>"},{"location":"heuristics/#resumo","title":"Resumo","text":"<p>Ent\u00e3o, uma fun\u00e7\u00e3o heur\u00edstica \u00e9 como um \"truque\" que ajuda os computadores a  tomar decis\u00f5es mais rapidamente. Elas s\u00e3o super \u00fateis em IA para tornar os  algoritmos mais eficientes, mas \u00e9 importante escolher a heur\u00edstica certa para  o problema que voc\u00ea est\u00e1 tentando resolver.</p>"},{"location":"heuristics/#contribuindo-para-o-assunto-de-heuristicas","title":"Contribuindo para o assunto de heur\u00edsticas","text":""},{"location":"heuristics/#distancia-de-manhattan","title":"Dist\u00e2ncia de Manhattan","text":"<p>Um exemplo de heur\u00edstica \u00e9 a dist\u00e2ncia de Manhattan, que \u00e9 a dist\u00e2ncia entre dois pontos em um grid, se deslocando apenas na horizontal e vertical. Essa heur\u00edstica foi comentada brevemente em sala de aula por\u00e9m \u00e9 interessante aprofundar um pouco mais sobre ela.</p> <p>A dist\u00e2ncia de Manhattan \u00e9 uma fun\u00e7\u00e3o heur\u00edstica comumente usada em problemas  que envolvem grade ou espa\u00e7o bidimensional, como encontrar o caminho mais curto em um labirinto.</p> <p>Implementei uma esp\u00e9cie de jogo para experimentar com diferentes tipos de algoritmos de busca. O jogo \u00e9 um labirinto onde o jogador deve encontrar o caminho mais curto para chegar ao objetivo. O c\u00f3digo est\u00e1 dispon\u00edvel no Github.</p> <p>Para o algoritmo A* no jogo, implementei usando a Manhattan Distance para estimar o custo do caminho mais curto.</p> <p></p>"},{"location":"heuristics/#o-que-e-distancia-de-manhattan","title":"O que \u00e9 Dist\u00e2ncia de Manhattan?","text":"<p>A dist\u00e2ncia de Manhattan entre dois pontos ( A ) e ( B ) em um plano \u00e9 a  soma das diferen\u00e7as absolutas de suas coordenadas. Por exemplo, se  ( A=(x_1, y_1) ) e ( B=(x_2, y_2) ), a dist\u00e2ncia de Manhattan seria  ( |x_1 - x_2| + |y_1 - y_2| ).</p>"},{"location":"heuristics/#como-e-utilizada-como-heuristica","title":"Como \u00e9 Utilizada como Heur\u00edstica?","text":"<p>Suponha que voc\u00ea est\u00e1 resolvendo um problema de labirinto em uma grade 2D e  quer encontrar o caminho mais curto de um ponto inicial a um ponto final.  Voc\u00ea pode usar a dist\u00e2ncia de Manhattan como uma fun\u00e7\u00e3o heur\u00edstica para estimar  o \"custo\" para chegar do ponto atual ao destino. O algoritmo de busca, como   A*, usaria essa estimativa para priorizar quais caminhos explorar.</p>"},{"location":"heuristics/#vantagens","title":"Vantagens","text":"<ol> <li>Simplicidade: \u00c9 f\u00e1cil de calcular.</li> <li>Efici\u00eancia: Ajuda o algoritmo de busca a focar nos caminhos mais  promissores, acelerando a solu\u00e7\u00e3o do problema.</li> </ol>"},{"location":"heuristics/#limitacoes_1","title":"Limita\u00e7\u00f5es","text":"<ol> <li>Admissibilidade: Em alguns casos, pode n\u00e3o ser a melhor estimativa para  o custo real. Por exemplo, se o movimento diagonal \u00e9 permitido, a dist\u00e2ncia de  Manhattan pode superestimar o custo.</li> <li>Aplicabilidade: \u00c9 mais \u00fatil em espa\u00e7os bidimensionais ou em problemas  que podem ser mapeados em uma grade 2D.</li> </ol>"},{"location":"heuristics/#exemplo-em-um-problema-de-caminho-mais-curto","title":"Exemplo em um Problema de Caminho Mais Curto","text":"<p>Suponha que o ponto inicial esteja na coordenada (2, 3) e o ponto final esteja  na coordenada (5, 6). A dist\u00e2ncia de Manhattan entre esses pontos seria  ( |5-2| + |6-3| = 3 + 3 = 6 ).</p> <p>O algoritmo usaria essa dist\u00e2ncia para estimar que o custo para ir do ponto  inicial ao ponto final \u00e9 de aproximadamente 6 unidades. Isso ajuda o algoritmo  a priorizar rotas que parecem mais curtas, economizando tempo e recursos  computacionais.</p> <p>Ent\u00e3o, em resumo, a dist\u00e2ncia de Manhattan \u00e9 uma heur\u00edstica popular e \u00fatil,  especialmente para problemas que envolvem grades ou espa\u00e7os bidimensionais.</p>"},{"location":"heuristics/#bibliografia","title":"Bibliografia","text":"<p>https://edisciplinas.usp.br/pluginfile.php/7340740/mod_resource/content/1/IAPos_NA06.pdf</p> <p>https://www.geeksforgeeks.org/a-search-algorithm/</p> <p>https://xlinux.nist.gov/dads/HTML/manhattanDistance.html#:~:text=Definition%3A%20The%20distance%20between%20two,y1%20%2D%20y2%7C.</p>"},{"location":"history/","title":"Hist\u00f3ria","text":""},{"location":"history/#1950-alan-turing-e-john-mccarthy","title":"1950 - Alan Turing e John McCarthy","text":"<p>Alan Turing \u00e9 considerado o pai da ci\u00eancia da computa\u00e7\u00e3o, e por ser um dos primeiros a considerar a intelig\u00eancia artificial como um assunto de computa\u00e7\u00e3o tamb\u00e9m \u00e9 comumente considerado o pai da mesma. Em 1950, Turing publicou um  artigo chamado \"Computing Machinery and Intelligence\" onde ele aborda um \"Jogo da Imita\u00e7\u00e3o\" e que para um humano venc\u00ea-lo consistentemente, ele teria que testar se estava conversando com uma m\u00e1quina usando o \"Teste de Turing\" que consistiria de perguntas cujo uma m\u00e1quina n\u00e3o conseguiria responder igual um humano.</p> <p>Hoje em dia Testes de Turing s\u00e3o muito utilizados com o prop\u00f3sito de  identificar e bloquear bots e acessos automatizados em sites.</p> <p>Esses testes s\u00e3o conhecidos como CAPTCHA (Completely Automated Public Turing test to tell Computers and Humans Apart).</p> <p>E esses CAPTCHAs precisam evoluir conforme as m\u00e1quinas tamb\u00e9m evoluem no quesito de intelig\u00eancia artificial. Em breve discutirei mais sobre esse assunto.</p> <p>J\u00e1 sobre o termo \"Intelig\u00eancia Artificial\" foi cunhado por John McCarthy,  do MIT, em 1955. O termo se referia \u00e0 constru\u00e7\u00e3o de um programa de computador que fosse capaz de realizar tarefas que normalmente era realizado por seres humanos e exigia processos mentais de alto n\u00edvel, onde h\u00e1 rela\u00e7\u00e3o de  aprendizado, mem\u00f3ria e racioc\u00ednio cr\u00edtico trabalhando em conjunto.</p> <p>Arthur Samuel, em 1956, utilizou a t\u00e9cnica de aprendizado por refor\u00e7o para ensinar computadores a jogar damas.</p>"},{"location":"history/#1950-matematica-e-xadrez","title":"1950+ - Matem\u00e1tica e Xadr\u00eaz","text":"<p>Em 1951, foi criado uma calculadora (SNARC) que era implementada usando um mecanismo similar a uma rede neural, essa calculadora se utilizava de um processo de tentativa e erro para aprender.</p> <p>Pr\u00f3ximo a 1960, um programa de computador chamado MANIAC  (Mathematical Analyzer, Numerical Integrator, and Computer or  Mathematical Analyzer, Numerator, Integrator, and Computer) foi desenvolvido e, por falta de poder computacional na \u00e9poca, era capaz de jogar uma varia\u00e7\u00e3o de xadr\u00eaz que contava com um tabuleiro de dimens\u00f5es 6x6  conhecido como Los Alamos Chess.</p> <p>Devido \u00e0 limita\u00e7\u00f5es de poder computacional, os estudos de intelig\u00eancia  artificial tiveram uma pequena pausa nesse per\u00edodo.</p>"},{"location":"history/#1970-inverno-da-ia","title":"1970 - Inverno da IA","text":"<p>Tivemos outro per\u00edodo de pausa da intelig\u00eancia artificial que ocorreu entre os anos 70 e o come\u00e7o dos anos 80. Esse per\u00edodo ficou conhecido como \"Inverno da IA\". Onde n\u00e3o existia muita novidade sobre o assunto e houveram muitos cortes nos investimentos da \u00e1rea.</p>"},{"location":"history/#1980-comercial","title":"1980+ - Comercial","text":"<p>Em 1980, devido \u00e0 evolu\u00e7\u00e3o do poder computacional, a intelig\u00eancia artificial voltou a ser um assunto de estudo e, nesse per\u00edodo, a intelig\u00eancia artificial come\u00e7ou a ser utilizada para fins comerciais. Os sistemas desenvolvidos nessa  \u00e9poca, foram os primeiros a serem reconhecidos como sistemas especialistas.</p> <p>Suas aplica\u00e7\u00f5es eram diversas e eles podiam desempenhar tarefas como an\u00e1lise de risco de cr\u00e9dico banc\u00e1rio, ger\u00eanciamento de riscos e at\u00e9 algoritmos de otimiza\u00e7\u00e3o de desempenho em negocia\u00e7\u00e3o de a\u00e7\u00f5es financeiras.</p>"},{"location":"history/#1990-internet-muitos-dados-e-aplicacoes-famosas","title":"1990 - Internet, muitos dados e aplica\u00e7\u00f5es famosas","text":""},{"location":"history/#internet","title":"Internet","text":"<p>Em 1990, a internet come\u00e7ou a se popularizar e com isso, a quantidade de dados dispon\u00edveis para serem processados aumentou exponencialmente.  Com isso, a intelig\u00eancia artificial come\u00e7ou a ser utilizada para processar esses dados e extrair informa\u00e7\u00f5es \u00fateis para os usu\u00e1rios e dos usu\u00e1rios.</p>"},{"location":"history/#guerra-do-golfo","title":"Guerra do Golfo","text":"<p>Em 1991, durante a Guerra do Golfo, os Estados Unidos da Am\u00e9rica utilizaram uma ferramenta chamada de Dynamic Analysis and Replanning Tool (DART) que era um sistema especialista que auxiliava os militares a planejar suas miss\u00f5es.</p> <p>Esse sistema especialista levava em considera\u00e7\u00e3o diversos fatores como condi\u00e7\u00f5es clim\u00e1ticas, condi\u00e7\u00f5es do terreno, condi\u00e7\u00f5es de tr\u00e1fego para poder prever rotas e recursos para se ganhar a guerra. Normalmente se levaria algumas semanas para planejar uma miss\u00e3o por m\u00e9todos tradicionais, por\u00e9m usando a DART isso foi poss\u00edvel em apenas algumas horas.</p>"},{"location":"history/#kasparov-vs-deep-blue","title":"Kasparov VS Deep Blue","text":"<p>Inicialmente os programas que eram capazes de jogar xadr\u00eaz conseguiam ganhar apenas no n\u00edvel amador e n\u00e3o eram capazes de vencer um jogador profissional. </p> <p>Deep Blue foi um programa de computador desenvolvido pela IBM que foi capaz de vencer o campe\u00e3o mundial de xadr\u00eaz, Garry Kasparov, em 1997.  Esse foi um marco hist\u00f3rico para a intelig\u00eancia artificial, pois foi a primeira vez que um programa de computador venceu um campe\u00e3o mundial de xadr\u00eaz.</p>"},{"location":"history/#2000-big-data","title":"2000 - Big Data","text":"<p>Com o aumento da quantidade de dados dispon\u00edveis, a intelig\u00eancia artificial come\u00e7ou a ser utilizada para processar esses dados e extrair informa\u00e7\u00f5es \u00fateis para os usu\u00e1rios e dos usu\u00e1rios. Tradicionalmente, os dados eram armazenados e processados usando SGBDs (Sistemas Gerenciadores de Banco de Dados) e processados usando SQL (Structured Query Language).</p> <p>O volume de dados come\u00e7ou a ser t\u00e3o grande que o armazenamento e poder de processamento das empresas (utilizando SGBDs) n\u00e3o era mais suficiente para  processar esses dados. Com isso, come\u00e7ou a surgir a ideia de armazenar esses dados em nuvem e utilizar o poder de processamento de outras empresas. Este conceito \u00e9 conhecido como \"Big Data\".</p> <p>A Big Data \u00e9 de suma import\u00e2ncia para treinamento de intelig\u00eancia artificiais hoje em dia, visto que hoje em dia \u00e9 poss\u00edvel utilizar esses dados que possuem um grande volume e uma grande variedade de dados para treinar algoritmos.</p>"},{"location":"history/#2010-deep-learning","title":"2010 - Deep Learning","text":"<p>Deep Learning \u00e9 uma sub-\u00e1rea do campo da intelig\u00eancia artificial que surgiu em meados de 2010. Essa \u00e1rea da intelig\u00eancia artificial alavancou os estudos sobre reconhecimento de imagens, processamento de linguagem natura,  reconhecimento de voz e muitas outras \u00e1reas.</p>"},{"location":"history/#opiniao-sobre-a-historia-da-ia","title":"Opini\u00e3o sobre a hist\u00f3ria da IA","text":"<p>Na minha opini\u00e3o, n\u00e3o h\u00e1 muito o que se adicionar sobre fatos hist\u00f3ricos que  ocorreram h\u00e1 muito tempo pois \u00e9 o que \u00e9. Por\u00e9m, \u00e9 interessante notar que a intelig\u00eancia artificial \u00e9 um assunto que j\u00e1 existe h\u00e1 muito tempo e que est\u00e1 em constante evolu\u00e7\u00e3o.</p> <p>Essa evolu\u00e7\u00e3o da IA vale a pena n\u00e3o s\u00f3 o  conhecimento e o aprendizado, mas tamb\u00e9m vale a discuss\u00e3o de como isso pode  afetar o futuro visto que estamos em um per\u00edodo pr\u00f3ximo ao que se pode considerar como uma revolu\u00e7\u00e3o das intelig\u00eancias artificiais, onde temos novos modelos de algoritmos capazes de realizar uma gama enorme fun\u00e7\u00f5es que humanos levam anos para aprender e horas ou dias para colocar uma atividade em pr\u00e1tica.</p> <p></p> <p>Um dos assuntos que me chama aten\u00e7\u00e3o \u00e9 sobre o CAPTCHA, e a preocupa\u00e7\u00e3o da gera\u00e7\u00e3o de novas formas de CAPTCHA, visto que hoje em dia a intelig\u00eancia artificial avan\u00e7ou a ponto de ser capaz de resolver CAPTCHAs com uma taxa de acerto melhor que humanos.</p> <p>Outro ponto sobre a rela\u00e7\u00e3o de CAPTCHA com intelig\u00eancia artificial \u00e9 que hoje em dia, os servi\u00e7os de CAPTCHA hoje em dia se utilizam de intelig\u00eancia artificial para gerar captchas e aprimorar modelos de reconhecimento de imagens.</p>"},{"location":"history/#veja-how-google-trains-ai-with-your-help-through-captcha","title":"Veja: How Google Trains AI with Your Help through CAPTCHA","text":""},{"location":"intro/","title":"Introdu\u00e7\u00e3o","text":""},{"location":"intro/#o-que-e-inteligencia-artificial","title":"O que \u00e9 Intelig\u00eancia Artificial?","text":"<p>O assunto \"intelig\u00eancia artificial\" come\u00e7a muito antes da ci\u00eancia da computa\u00e7\u00e3o existir. Hist\u00f3ricamente, existem mitos sobre uma intelig\u00eancia que n\u00e3o nasceu naturalmente, e sim, artificialmente. Como exemplos, podemos citar o mito grego  de Pigmale\u00e3o e o mito judaico-crist\u00e3o de Golem. Estes mitos falam sobre seres que foram criados e que possuem uma intelig\u00eancia similar a dos humanos. Ent\u00e3o quando falamos de intelig\u00eancia artificial, podemos dizer que se trata de uma intelig\u00eancia criada, apesar de que hoje em dia o termo \u00e9 comumente associado \u00e0 computa\u00e7\u00e3o. Por isso, vamos abordar o assunto com o foco na computa\u00e7\u00e3o.</p> <p>Apesar do nome conter a palavra \"intelig\u00eancia\", \u00e9 dif\u00edcil definir o que de fato \u00e9 uma intelig\u00eancia e tamb\u00e9m se um programa de computador pode possuir essa qualidade t\u00e3o qual um humano.</p>"},{"location":"intro/#fidelidade-a-performance-humana-x-racionalidade","title":"Fidelidade \u00e0 performance humana x Racionalidade","text":"<p>O ser humano nem sempre obt\u00e9m a resposta \u00f3tima, por\u00e9m \u00e9 capaz de obter uma resposta satisfat\u00f3ria que leva em considera\u00e7\u00f5es muitos aspectos do problema em quest\u00e3o. Contudo, o ser humano n\u00e3o \u00e9 100% racional, e acaba por muitas vezes tomando em considera\u00e7\u00e3o as emo\u00e7\u00f5es e sentimentos para tomar decis\u00f5es.</p> <p>J\u00e1 uma m\u00e1quina executa uma l\u00f3gica implementada em forma de algoritmo, a princ\u00edpio, sem tomar emo\u00e7\u00f5es em considera\u00e7\u00e3o.</p> <p>Acredito que a problem\u00e1tica nesse tema \u00e9 fazer uma m\u00e1quina conseguir tomar decis\u00f5es levando a racionalidade humana como base, por\u00e9m excluindo as emo\u00e7\u00f5es para se obter um resultado \u00f3timo, e n\u00e3o apenas replicar comportamento humano.</p>"},{"location":"intro/#raciocinio-x-comportamento","title":"Raciocinio x Comportamento","text":"<p>O racioc\u00ednio \u00e9 a capacidade de um ser de obter conclus\u00f5es l\u00f3gicas a partir de premissas. J\u00e1 o comportamento \u00e9 a forma como um ser age em determinadas situa\u00e7\u00f5es.</p> <p>A intelig\u00eancia artificial pode ser configurada para ambos os prop\u00f3sitos, dependendo do problema que se deseja resolver. As vezes queremos replicar  o comportamento humano para passar em um teste de turing, ou gerar uma imagem que pare\u00e7a pintada por um humano; Outrora precisamos de encontrar uma solu\u00e7\u00e3o \u00f3tima para o design de uma pe\u00e7a de um carro, ou para a rota de um caminh\u00e3o.</p> <p>Um exemplo para replicar comportamento humano poderia ser as imagens geradas por intelig\u00eancia artificial. Por exemplo as que s\u00e3o publicadas no site  Lexica.</p> <p>Outro exemplo, para otimiza\u00e7\u00e3o de designs de engenharia poderia ser os carros desenvolvidos por intelig\u00eancia artificial, como os apresentados no v\u00eddeo de Donut que buscam utilizar menos materiais, ser mais resistentes e mais r\u00e1pidos, feitos automaticamente por impressoras 3d.</p>"},{"location":"intro/#modelo-padrao","title":"Modelo Padr\u00e3o","text":"<p>Pode ser chamado, de Modelo Padr\u00e3o, o paradigma geral, dentro da \u00e1rea de intelig\u00eancia artificial, sobre o estudo de agentes que agem de forma correta, ou seja, de uma forma  racional esperada.</p>"},{"location":"intro/#fundamentos-da-inteligencia-artificial","title":"Fundamentos da Intelig\u00eancia Artificial","text":"<p>Os fundamentos da Intelig\u00eancia Artificial (IA) abrangem \u00e1reas como aprendizado de m\u00e1quina, l\u00f3gica simb\u00f3lica, redes neurais e tomada de decis\u00e3o baseada em  regras. Esses pilares s\u00e3o combinados para criar sistemas de IA que podem  realizar tarefas diversas, como reconhecimento de voz e classifica\u00e7\u00e3o de  imagens. O campo est\u00e1 em constante evolu\u00e7\u00e3o, com novas t\u00e9cnicas e modelos  sendo regularmente desenvolvidos para aprimorar o desempenho e a precis\u00e3o  desses sistemas. Tais tarefas realizadas por IA impactam nossa vida todo dia e a tend\u00eancia \u00e9 que essas tarefas se tornem cada vez mais presente para alterar a forma que trabalhamos e vivemos, facilitando e dando mais autonomia para os seres humanos.</p> <p>Enquanto a IA \u00e9, sem d\u00favida, uma conquista impressionante da engenharia de  software, n\u00e3o podemos ignorar seus desafios \u00e9ticos e t\u00e9cnicos. Por exemplo,  sistemas de IA treinados com dados enviesados podem perpetuar ou at\u00e9 mesmo  intensificar preconceitos existentes. Al\u00e9m disso, a \"caixa-preta\" de muitos  algoritmos de aprendizado profundo torna dif\u00edcil entender completamente  como as decis\u00f5es s\u00e3o tomadas, o que \u00e9 um problema s\u00e9rio em aplica\u00e7\u00f5es  cr\u00edticas, como diagn\u00f3stico m\u00e9dico ou sistemas judiciais. Como futuros  engenheiros de software, precisamos ser conscientes dessas quest\u00f5es ao  desenvolver e implementar novas tecnologias em IA.</p>"},{"location":"problem_solving_agents/","title":"Agentes solucionadores de problemas","text":""},{"location":"problem_solving_agents/#definicao-de-problema","title":"Defini\u00e7\u00e3o de problema","text":"<p>Podemos definir um problema usando quatro caracter\u00edsticas:</p> <ul> <li>Estado inicial do problema</li> <li>A\u00e7\u00f5es poss\u00edveis</li> <li>Teste de t\u00e9rmino</li> <li>Fun\u00e7\u00e3o de custo da solu\u00e7\u00e3o</li> </ul>"},{"location":"problem_solving_agents/#estado-inicial-do-problema","title":"Estado inicial do problema","text":"<p>Onde o agente \u00e9 iniciado.  Ex: posi\u00e7\u00e3o inicial de um rob\u00f4.</p>"},{"location":"problem_solving_agents/#acoes-possiveis","title":"A\u00e7\u00f5es poss\u00edveis","text":"<p>Conjunto de a\u00e7\u00f5es que o agente pode executar, pela fun\u00e7\u00e3o sucessor ou pelo conjunto de operadores.  Sendo que a fun\u00e7\u00e3o sucessor \u00e9 uma fun\u00e7\u00e3o que recebe um estado e retorna um conjunto de a\u00e7\u00f5es poss\u00edveis. E o conjunto de operadores \u00e9 um conjunto de a\u00e7\u00f5es poss\u00edveis para gerar os sucessores. Ex: movimentar-se para frente, para tr\u00e1s, para esquerda ou para direita.</p>"},{"location":"problem_solving_agents/#um-teste-de-termino","title":"Um teste de t\u00e9rmino","text":"<p>Define um conjunto de estados que s\u00e3o considerados como solu\u00e7\u00e3o, sendo que estes estados podem ser chamados de objetivo. Por\u00e9m esse conjunto de estados pode ser algo mais simples e abstrato, assim como uma situa\u00e7\u00e3o de check-mate no xadrez.</p>"},{"location":"problem_solving_agents/#funcao-de-custo-da-solucao","title":"Fun\u00e7\u00e3o de custo da solu\u00e7\u00e3o","text":"<p>\u00c9 uma fun\u00e7\u00e3o que recebe uma solu\u00e7\u00e3o e retorna um valor num\u00e9rico que representa o custo da solu\u00e7\u00e3o, tamb\u00e9m conhecida por medida de desempenho.  O objetivo \u00e9 encontrar a solu\u00e7\u00e3o com o menor custo poss\u00edvel.</p>"},{"location":"problem_solving_agents/#problemas-de-malha-fechada-e-malha-aberta-em-agentes-de-solucoes-de-problemas","title":"Problemas de Malha Fechada e Malha Aberta em Agentes de Solu\u00e7\u00f5es de Problemas","text":"<p>Os termos \"malha fechada\" e \"malha aberta\" s\u00e3o frequentemente usados para  descrever o grau de intera\u00e7\u00e3o e feedback entre um agente e seu ambiente.  Ambos t\u00eam implica\u00e7\u00f5es importantes no design e na opera\u00e7\u00e3o de agentes de  solu\u00e7\u00f5es de problemas.</p>"},{"location":"problem_solving_agents/#malha-fechada","title":"Malha Fechada","text":"<p>Em um sistema de malha fechada, o agente recebe feedback cont\u00ednuo do ambiente  e ajusta suas a\u00e7\u00f5es com base nesse feedback. Isso \u00e9 comum em cen\u00e1rios onde o  estado do ambiente pode mudar dinamicamente, e o agente precisa se adaptar a  essas mudan\u00e7as em tempo real.</p>"},{"location":"problem_solving_agents/#como-funciona","title":"Como Funciona:","text":"<p>O agente toma uma a\u00e7\u00e3o, observa o resultado e o usa para informar a pr\u00f3xima  a\u00e7\u00e3o.</p>"},{"location":"problem_solving_agents/#aplicacoes","title":"Aplica\u00e7\u00f5es:","text":"<p>Rob\u00f3tica, onde o rob\u00f4 precisa se ajustar a obst\u00e1culos em movimento. Mercados financeiros, onde o agente de negocia\u00e7\u00e3o precisa se adaptar \u00e0s  flutua\u00e7\u00f5es de pre\u00e7o.</p>"},{"location":"problem_solving_agents/#desafios","title":"Desafios:","text":"<p>Requer capacidade de processamento em tempo real. Pode exigir algoritmos de aprendizado por refor\u00e7o ou outros m\u00e9todos de  aprendizado de m\u00e1quina para adaptar-se eficazmente.</p>"},{"location":"problem_solving_agents/#malha-aberta","title":"Malha Aberta","text":"<p>Em um sistema de malha aberta, o agente n\u00e3o recebe feedback em tempo real ou  n\u00e3o o utiliza para ajustar suas a\u00e7\u00f5es futuras. Ele se baseia mais em um modelo  predefinido do ambiente e em um plano estabelecido.</p>"},{"location":"problem_solving_agents/#como-funciona_1","title":"Como Funciona:","text":"<p>O agente toma uma s\u00e9rie de a\u00e7\u00f5es com base em um plano predefinido, sem  necessariamente revisar ou ajustar o plano em resposta \u00e0s mudan\u00e7as no ambiente.</p>"},{"location":"problem_solving_agents/#aplicacoes_1","title":"Aplica\u00e7\u00f5es:","text":"<p>Resolu\u00e7\u00e3o de problemas de quebra-cabe\u00e7a como o Cubo de Rubik. Planejamento de rota em um mapa est\u00e1tico.</p>"},{"location":"problem_solving_agents/#desafios_1","title":"Desafios:","text":"<p>Menos adapt\u00e1vel a mudan\u00e7as no ambiente. O plano inicial precisa ser bem elaborado para garantir o sucesso.</p>"},{"location":"problem_solving_agents/#interseccao-entre-malha-fechada-e-malha-aberta","title":"Intersec\u00e7\u00e3o entre Malha Fechada e Malha Aberta","text":"<p>Em muitas aplica\u00e7\u00f5es pr\u00e1ticas, os agentes operam em um espectro entre malha  fechada e malha aberta. Por exemplo, um carro aut\u00f4nomo pode ter um plano de  rota geral (abordagem de malha aberta), mas ainda precisa se adaptar a outros  ve\u00edculos e condi\u00e7\u00f5es da estrada em tempo real (abordagem de malha fechada).</p> <p>Problemas de malha fechada s\u00e3o n\u00e3o deterministicos por sofrer interfer\u00eancias externas do ambiente. J\u00e1 problemas de malha aberta s\u00e3o determin\u00edsticos pois n\u00e3o sofrem interfer\u00eancias externas do ambiente.</p>"},{"location":"problem_solving_agents/#em-resumo","title":"Em Resumo","text":"<p>A escolha entre malha fechada e malha aberta depender\u00e1 do problema espec\u00edfico  que o agente de solu\u00e7\u00f5es de problemas est\u00e1 tentando resolver, do ambiente em  que est\u00e1 operando e dos recursos computacionais dispon\u00edveis. Ambos t\u00eam seus  pr\u00f3prios conjuntos de desafios e vantagens, e compreend\u00ea-los \u00e9 crucial para  o design eficaz de agentes inteligentes.</p>"},{"location":"problem_solving_agents/#bibliografia","title":"Bibliografia","text":"<p>https://edisciplinas.usp.br/pluginfile.php/4848799/mod_resource/content/3/2019-ProblemasComoBusca-BuscaCega.pdf</p> <p>https://edisciplinas.usp.br/pluginfile.php/4183182/mod_resource/content/1/Aula1V2017.pdf</p>"},{"location":"problem_types/","title":"Problemas de Malha Fechada e Malha Aberta em Agentes de Solu\u00e7\u00f5es de Problemas","text":"<p>Os termos \"malha fechada\" e \"malha aberta\" s\u00e3o frequentemente usados para  descrever o grau de intera\u00e7\u00e3o e feedback entre um agente e seu ambiente.  Ambos t\u00eam implica\u00e7\u00f5es importantes no design e na opera\u00e7\u00e3o de agentes de  solu\u00e7\u00f5es de problemas.</p>"},{"location":"problem_types/#malha-fechada","title":"Malha Fechada","text":"<p>Em um sistema de malha fechada, o agente recebe feedback cont\u00ednuo do ambiente  e ajusta suas a\u00e7\u00f5es com base nesse feedback. Isso \u00e9 comum em cen\u00e1rios onde o  estado do ambiente pode mudar dinamicamente, e o agente precisa se adaptar a  essas mudan\u00e7as em tempo real.</p>"},{"location":"problem_types/#como-funciona","title":"Como Funciona:","text":"<p>O agente toma uma a\u00e7\u00e3o, observa o resultado e o usa para informar a pr\u00f3xima  a\u00e7\u00e3o.</p>"},{"location":"problem_types/#aplicacoes","title":"Aplica\u00e7\u00f5es:","text":"<p>Rob\u00f3tica, onde o rob\u00f4 precisa se ajustar a obst\u00e1culos em movimento. Mercados financeiros, onde o agente de negocia\u00e7\u00e3o precisa se adaptar \u00e0s  flutua\u00e7\u00f5es de pre\u00e7o.</p>"},{"location":"problem_types/#desafios","title":"Desafios:","text":"<p>Requer capacidade de processamento em tempo real. Pode exigir algoritmos de aprendizado por refor\u00e7o ou outros m\u00e9todos de  aprendizado de m\u00e1quina para adaptar-se eficazmente.</p>"},{"location":"problem_types/#malha-aberta","title":"Malha Aberta","text":"<p>Em um sistema de malha aberta, o agente n\u00e3o recebe feedback em tempo real ou  n\u00e3o o utiliza para ajustar suas a\u00e7\u00f5es futuras. Ele se baseia mais em um modelo  predefinido do ambiente e em um plano estabelecido.</p>"},{"location":"problem_types/#como-funciona_1","title":"Como Funciona:","text":"<p>O agente toma uma s\u00e9rie de a\u00e7\u00f5es com base em um plano predefinido, sem  necessariamente revisar ou ajustar o plano em resposta \u00e0s mudan\u00e7as no ambiente.</p>"},{"location":"problem_types/#aplicacoes_1","title":"Aplica\u00e7\u00f5es:","text":"<p>Resolu\u00e7\u00e3o de problemas de quebra-cabe\u00e7a como o Cubo de Rubik. Planejamento de rota em um mapa est\u00e1tico.</p>"},{"location":"problem_types/#desafios_1","title":"Desafios:","text":"<p>Menos adapt\u00e1vel a mudan\u00e7as no ambiente. O plano inicial precisa ser bem elaborado para garantir o sucesso.</p>"},{"location":"problem_types/#interseccao-entre-malha-fechada-e-malha-aberta","title":"Intersec\u00e7\u00e3o entre Malha Fechada e Malha Aberta","text":"<p>Em muitas aplica\u00e7\u00f5es pr\u00e1ticas, os agentes operam em um espectro entre malha  fechada e malha aberta. Por exemplo, um carro aut\u00f4nomo pode ter um plano de  rota geral (abordagem de malha aberta), mas ainda precisa se adaptar a outros  ve\u00edculos e condi\u00e7\u00f5es da estrada em tempo real (abordagem de malha fechada).</p> <p>Problemas de malha fechada s\u00e3o n\u00e3o deterministicos por sofrer interfer\u00eancias externas do ambiente. J\u00e1 problemas de malha aberta s\u00e3o determin\u00edsticos pois n\u00e3o sofrem interfer\u00eancias externas do ambiente.</p>"},{"location":"problem_types/#em-resumo","title":"Em Resumo","text":"<p>A escolha entre malha fechada e malha aberta depender\u00e1 do problema espec\u00edfico  que o agente de solu\u00e7\u00f5es de problemas est\u00e1 tentando resolver, do ambiente em  que est\u00e1 operando e dos recursos computacionais dispon\u00edveis. Ambos t\u00eam seus  pr\u00f3prios conjuntos de desafios e vantagens, e compreend\u00ea-los \u00e9 crucial para  o design eficaz de agentes inteligentes.</p>"},{"location":"problem_types/#bibliografia","title":"Bibliografia","text":"<p>https://edisciplinas.usp.br/pluginfile.php/4848799/mod_resource/content/3/2019-ProblemasComoBusca-BuscaCega.pdf</p> <p>https://edisciplinas.usp.br/pluginfile.php/4183182/mod_resource/content/1/Aula1V2017.pdf</p>"},{"location":"search_algorithms/","title":"Algoritmos de Busca","text":"<p>Algoritmos de busca s\u00e3o essenciais para explorar um espa\u00e7o de estados a fim de  encontrar uma solu\u00e7\u00e3o para um determinado problema. Eles s\u00e3o classificados  principalmente em dois tipos: Busca Cega (ou Busca N\u00e3o-Informada) e Busca  Informada.</p>"},{"location":"search_algorithms/#busca-cega-busca-nao-informada","title":"Busca Cega (Busca N\u00e3o-Informada)","text":"<p>Esses algoritmos n\u00e3o t\u00eam informa\u00e7\u00f5es adicionais sobre estados al\u00e9m daqueles  que est\u00e3o expl\u00edcitos no problema. Eles s\u00e3o chamados de \"cegos\" porque exploram  o espa\u00e7o de estados sem qualquer dire\u00e7\u00e3o guiada para encontrar a solu\u00e7\u00e3o.</p>"},{"location":"search_algorithms/#algoritmos-comuns","title":"Algoritmos Comuns:","text":"<ul> <li>Busca em Largura (Breadth-First Search, BFS)</li> <li>Busca em Profundidade (Depth-First Search, DFS)</li> <li>Busca de Custo Uniforme</li> </ul>"},{"location":"search_algorithms/#como-funciona","title":"Como Funciona:","text":"<p>Come\u00e7am a partir de um estado inicial e expandem a fronteira de estados  poss\u00edveis at\u00e9 atingir o estado objetivo.</p>"},{"location":"search_algorithms/#comparacao-entre-breadth-first-search-depth-first-search-e-busca-de-custo-uniforme","title":"Compara\u00e7\u00e3o entre Breadth-First Search, Depth-First Search e Busca de Custo Uniforme","text":"<p>Esses tr\u00eas algoritmos s\u00e3o comumente usados para a resolu\u00e7\u00e3o de problemas e t\u00eam  suas pr\u00f3prias vantagens e desvantagens. Abaixo, segue uma compara\u00e7\u00e3o detalhada  entre Breadth-First Search (BFS), Depth-First Search (DFS) e Busca de Custo  Uniforme (UCS).</p>"},{"location":"search_algorithms/#breadth-first-search-bfs","title":"Breadth-First Search (BFS)","text":""},{"location":"search_algorithms/#exemplo-de-algoritmo-em-python","title":"Exemplo de algoritmo em Python","text":"<pre><code>from collections import deque\n\ndef bfs(graph, start, goal):\n    visited = set()\n    queue = deque([(start, [start])])\n\n    while queue:\n        (current_node, path) = queue.popleft()\n\n        if current_node not in visited:\n            visited.add(current_node)\n\n            if current_node == goal:\n                return path\n\n            for neighbor in graph[current_node]:\n                queue.append((neighbor, path + [neighbor]))\n\n# Exemplo de uso\ngraph = {'A': ['B', 'C'], 'B': ['A', 'D'], 'C': ['A', 'E'], 'D': ['B'], 'E': ['C', 'F'], 'F': ['E']}\nprint(bfs(graph, 'A', 'F'))  # Output: ['A', 'C', 'E', 'F']\n</code></pre> <p>Mecanismo: Explora todos os vizinhos de um n\u00f3 antes de passar para os  vizinhos do pr\u00f3ximo n\u00edvel.</p> <p>Filosofia: \"Expandir primeiro na largura\".</p> <p>Completo: Sim, garante encontrar a solu\u00e7\u00e3o se uma existir.</p> <p>\u00d3timo: Sim, se o custo para cada passo for o mesmo.</p> <p>Uso de Mem\u00f3ria: Elevado, pois mant\u00e9m todos os n\u00f3s em mem\u00f3ria.</p> <p>Aplica\u00e7\u00f5es: \u00datil para encontrar o menor caminho em um espa\u00e7o de estados,  em problemas onde a solu\u00e7\u00e3o mais curta \u00e9 desejada.</p>"},{"location":"search_algorithms/#depth-first-search-dfs","title":"Depth-First Search (DFS)","text":""},{"location":"search_algorithms/#exemplo-de-algoritmo-em-python_1","title":"Exemplo de algoritmo em Python","text":"<pre><code>def dfs(graph, current_node, goal, visited=None, path=None):\n    if visited is None:\n        visited = set()\n    if path is None:\n        path = []\n\n    visited.add(current_node)\n    path.append(current_node)\n\n    if current_node == goal:\n        return path\n\n    for neighbor in graph[current_node]:\n        if neighbor not in visited:\n            new_path = dfs(graph, neighbor, goal, visited, path.copy())\n\n            if new_path:\n                return new_path\n\n# Exemplo de uso\ngraph = {'A': ['B', 'C'], 'B': ['A', 'D'], 'C': ['A', 'E'], 'D': ['B'], 'E': ['C', 'F'], 'F': ['E']}\nprint(dfs(graph, 'A', 'F'))  # Output: ['A', 'B', 'D', 'C', 'E', 'F']\n</code></pre> <p>Mecanismo: Explora t\u00e3o profundamente quanto poss\u00edvel ao longo de cada ramo  antes de retroceder.</p> <p>Filosofia: \"Expandir primeiro em profundidade\".</p> <p>Completo: N\u00e3o necessariamente, especialmente em \u00e1rvores infinitas.</p> <p>\u00d3timo: N\u00e3o, pode encontrar uma solu\u00e7\u00e3o sub\u00f3tima.</p> <p>Uso de Mem\u00f3ria: Menor comparado ao BFS, pois armazena apenas o caminho da raiz at\u00e9 o n\u00f3 atual.</p> <p>Aplica\u00e7\u00f5es: \u00datil em cen\u00e1rios como labirintos e jogos de estrat\u00e9gia, onde  encontrar qualquer solu\u00e7\u00e3o v\u00e1lida \u00e9 mais importante do que encontrar a solu\u00e7\u00e3o  mais curta.</p>"},{"location":"search_algorithms/#busca-de-custo-uniforme-ucs","title":"Busca de Custo Uniforme (UCS)","text":""},{"location":"search_algorithms/#exemplo-de-algoritmo-em-python_2","title":"Exemplo de algoritmo em Python","text":"<pre><code>import heapq\n\ndef ucs(graph, start, goal):\n    visited = set()\n    queue = [(0, start, [])]\n\n    while queue:\n        (cost, current_node, path) = heapq.heappop(queue)\n\n        if current_node not in visited:\n            visited.add(current_node)\n            path = path + [current_node]\n\n            if current_node == goal:\n                return cost, path\n\n            for neighbor, edge_cost in graph[current_node].items():\n                heapq.heappush(queue, (cost + edge_cost, neighbor, path))\n\n# Exemplo de uso\ngraph = {'A': {'B': 1, 'C': 4}, 'B': {'A': 1, 'D': 2}, 'C': {'A': 4, 'E': 3}, 'D': {'B': 2}, 'E': {'C': 3, 'F': 5}, 'F': {'E': 5}}\nprint(ucs(graph, 'A', 'F'))  # Output: (9, ['A', 'B', 'D', 'C', 'E', 'F'])\n</code></pre> <p>Mecanismo: Expandir o n\u00f3 com o menor custo acumulado at\u00e9 agora.</p> <p>Filosofia: \"Expandir com base no custo mais baixo\".</p> <p>Completo: Sim, desde que o custo de cada aresta seja maior que algum valor \u03b5&gt;0.</p> <p>\u00d3timo: Sim, sempre encontra a solu\u00e7\u00e3o de menor custo.</p> <p>Uso de Mem\u00f3ria: Pode ser alto, pois mant\u00e9m todos os n\u00f3s visitados em mem\u00f3ria.</p> <p>Aplica\u00e7\u00f5es: \u00datil em problemas de roteamento, como encontrar o caminho mais curto em um mapa com diferentes custos de deslocamento.</p>"},{"location":"search_algorithms/#resumo-das-diferencas","title":"Resumo das Diferen\u00e7as","text":""},{"location":"search_algorithms/#objetivo","title":"Objetivo:","text":"<ul> <li>BFS \u00e9 geralmente usado para encontrar o caminho mais curto em termos de n\u00famero de passos.</li> <li>DFS \u00e9 usado para encontrar qualquer solu\u00e7\u00e3o v\u00e1lida de forma eficiente em mem\u00f3ria.</li> <li>UCS \u00e9 usado para encontrar o caminho de menor custo.</li> </ul>"},{"location":"search_algorithms/#eficiencia","title":"Efici\u00eancia:","text":"<ul> <li>BFS e UCS s\u00e3o geralmente mais lentos mas produzem melhores solu\u00e7\u00f5es.</li> <li>DFS \u00e9 mais r\u00e1pido e usa menos mem\u00f3ria, mas pode encontrar solu\u00e7\u00f5es sub\u00f3timas.</li> </ul>"},{"location":"search_algorithms/#complexidade-de-espaco","title":"Complexidade de Espa\u00e7o:","text":"<ul> <li>BFS e UCS podem exigir mais mem\u00f3ria.</li> <li>DFS \u00e9 mais eficiente em termos de mem\u00f3ria.</li> </ul>"},{"location":"search_algorithms/#garantia-de-solucao-otima","title":"Garantia de Solu\u00e7\u00e3o \u00d3tima:","text":"<ul> <li>BFS s\u00f3 \u00e9 \u00f3timo quando todos os passos t\u00eam o mesmo custo.</li> <li>DFS n\u00e3o garante uma solu\u00e7\u00e3o \u00f3tima.</li> <li>UCS sempre encontra uma solu\u00e7\u00e3o \u00f3tima, dado que todos os custos de aresta sejam positivos.</li> </ul>"},{"location":"search_algorithms/#busca-informada","title":"Busca Informada","text":"<p>Esses algoritmos usam informa\u00e7\u00f5es adicionais  (geralmente na forma de uma fun\u00e7\u00e3o heur\u00edstica) para fazer escolhas mais  informadas durante a busca, possibilitando encontrar solu\u00e7\u00f5es de forma mais  eficiente.</p>"},{"location":"search_algorithms/#algoritmos-comuns_1","title":"Algoritmos Comuns:","text":"<ul> <li>A* (A-Star)</li> <li>Best-First Search</li> <li>Hill Climbing</li> </ul>"},{"location":"search_algorithms/#como-funciona_1","title":"Como Funciona:","text":"<p>Utilizam uma fun\u00e7\u00e3o heur\u00edstica para estimar o custo do estado atual at\u00e9 o  estado objetivo, priorizando estados que parecem levar a uma solu\u00e7\u00e3o mais  eficiente.</p>"},{"location":"search_algorithms/#comparacao-entre-a-best-first-search-e-hill-climbing","title":"Compara\u00e7\u00e3o entre A*, Best-First Search e Hill Climbing","text":"<p>Esses tr\u00eas algoritmos s\u00e3o tipos de buscas informadas que usam heur\u00edsticas para  direcionar a explora\u00e7\u00e3o. Aqui est\u00e3o suas principais caracter\u00edsticas, vantagens  e desvantagens:</p>"},{"location":"search_algorithms/#a-a-star","title":"A* (A-Star)","text":"<pre><code>\"\"\"\nEste exemplo contempla o uso da dist\u00e2ncia de Manhattan como heur\u00edstica.\n\"\"\"\nimport heapq\n\ndef manhattan_distance(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef a_star(graph, start, goal):\n    open_set = [(0, start, [])]  # (f_score, current_node, path)\n    visited = set()\n\n    while open_set:\n        f, current, path = heapq.heappop(open_set)\n\n        if current in visited:\n            continue\n\n        path = path + [current]\n        visited.add(current)\n\n        if current == goal:\n            return f, path\n\n        for neighbor, cost in graph[current].items():\n            g = f - manhattan_distance(current, goal)  # Recalculate g_score\n            h = manhattan_distance(neighbor, goal)\n            f_new = g + cost + h\n\n            heapq.heappush(open_set, (f_new, neighbor, path))\n\n# Exemplo de uso\ngraph = { (0, 0): {(0, 1): 1, (1, 0): 1.5},\n          (0, 1): {(0, 0): 1, (0, 2): 1},\n          (0, 2): {(0, 1): 1, (1, 2): 1},\n          (1, 0): {(0, 0): 1.5, (1, 1): 1},\n          (1, 1): {(1, 0): 1, (1, 2): 1},\n          (1, 2): {(1, 1): 1, (0, 2): 1} }\nstart = (0, 0)\ngoal = (1, 2)\nprint(a_star(graph, start, goal))  # Output: (3.5, [(0, 0), (1, 0), (1, 1), (1, 2)])\n</code></pre> <p>Mecanismo: Utiliza tanto o custo acumulado do n\u00f3 inicial at\u00e9 o n\u00f3 atual (g(n)) como uma fun\u00e7\u00e3o heur\u00edstica estimada do n\u00f3 atual ao n\u00f3 objetivo (h(n)) para priorizar a explora\u00e7\u00e3o.</p> <p>No exemplo acima foi usada a Dist\u00e2ncia de Manhattan como heur\u00edstica, por\u00e9m essa heur\u00edstica \u00e9 apenas um exemplo. O algoritmo pode usar outra fun\u00e7\u00e3o de heur\u00edstica ou combina\u00e7\u00e3o de fun\u00e7\u00f5es de heur\u00edsticas.</p> <p>Filosofia: \"Expandir o n\u00f3 que tem a menor soma de custos g(n) + h(n).\"</p> <p>Completo: Sim, desde que a heur\u00edstica seja admiss\u00edvel e consistente.</p> <p>\u00d3timo: Sim, sob as mesmas condi\u00e7\u00f5es.</p> <p>Aplica\u00e7\u00f5es: Pathfinding, planejamento de movimento, etc.</p> <p>A \u00e9 um algoritmo que tamb\u00e9m possui varia\u00e7\u00f5es, como o A Epsilon, que \u00e9 uma varia\u00e7\u00e3o do A* que permite que o algoritmo explore mais n\u00f3s, por\u00e9m com um custo maior. Isso \u00e9 \u00fatil para encontrar solu\u00e7\u00f5es mais rapidamente, por\u00e9m sub\u00f3timas. Refer\u00eancia sobre varia\u00e7\u00f5es do A*</p>"},{"location":"search_algorithms/#best-first-search","title":"Best-First Search","text":"<pre><code>import heapq\n\ndef best_first_search(graph, start, goal, heuristic):\n    open_set = [(heuristic(start, goal), start, [])]\n    visited = set()\n\n    while open_set:\n        _, current, path = heapq.heappop(open_set)\n\n        if current in visited:\n            continue\n\n        path = path + [current]\n        visited.add(current)\n\n        if current == goal:\n            return path\n\n        for neighbor in graph[current]:\n            h = heuristic(neighbor, goal)\n            heapq.heappush(open_set, (h, neighbor, path))\n\n# Exemplo de uso\ngraph = {'A': ['B', 'C'], 'B': ['D'], 'C': ['E', 'F'], 'D': [], 'E': [], 'F': []}\nheuristic = lambda x, y: ord(y) - ord(x)\nstart = 'A'\ngoal = 'F'\nprint(best_first_search(graph, start, goal, heuristic))  # Output: ['A', 'C', 'F']\n</code></pre> <p>Mecanismo: Utiliza apenas a fun\u00e7\u00e3o heur\u00edstica (h(n)) para direcionar a busca.</p> <p>Filosofia: \"Expandir o n\u00f3 que parece mais pr\u00f3ximo do objetivo com base na heur\u00edstica.\"</p> <p>Completo: N\u00e3o necessariamente.</p> <p>\u00d3timo: N\u00e3o.</p> <p>Aplica\u00e7\u00f5es: Problemas em que encontrar uma solu\u00e7\u00e3o rapidamente \u00e9 mais importante do que encontrar a melhor solu\u00e7\u00e3o.</p>"},{"location":"search_algorithms/#hill-climbing","title":"Hill Climbing","text":"<pre><code>def hill_climbing(graph, start, goal, heuristic):\n    current = start\n    path = [current]\n\n    while current != goal:\n        neighbors = [(neighbor, heuristic(neighbor, goal)) for neighbor in graph[current]]\n        if not neighbors:\n            return None  # Falhou em encontrar um caminho\n\n        # Escolhe o vizinho com a melhor heur\u00edstica\n        best_neighbor, _ = min(neighbors, key=lambda x: x[1])\n\n        if heuristic(best_neighbor, goal) &gt;= heuristic(current, goal):\n            return None  # Alcan\u00e7ado um m\u00e1ximo local\n\n        current = best_neighbor\n        path.append(current)\n\n    return path\n\n# Exemplo de uso\ngraph = {'A': ['B', 'C'], 'B': ['D'], 'C': ['E', 'F'], 'D': [], 'E': [], 'F': []}\nheuristic = lambda x, y: ord(y) - ord(x)\nstart = 'A'\ngoal = 'F'\nprint(hill_climbing(graph, start, goal, heuristic))  # Output: ['A', 'C', 'F']\n</code></pre> <p>Mecanismo: Escolhe o melhor n\u00f3 vizinho com base na heur\u00edstica e move-se para ele, sem manter um hist\u00f3rico.</p> <p>Filosofia: \"Sempre suba a colina. Se chegar ao topo, pare.\"</p> <p>Completo: N\u00e3o.</p> <p>\u00d3timo: N\u00e3o.</p> <p>Aplica\u00e7\u00f5es: Otimiza\u00e7\u00e3o local, onde encontrar um m\u00e1ximo ou m\u00ednimo local \u00e9 suficiente.</p>"},{"location":"search_algorithms/#resumo-das-diferencas_1","title":"Resumo das Diferen\u00e7as","text":"<p>Heur\u00edsticas:</p> <ul> <li>A* usa tanto o custo real at\u00e9 o ponto atual (g(n)) quanto uma estimativa para o objetivo (h(n)).</li> <li>Best-First e Hill Climbing usam apenas a estimativa para o objetivo (h(n)).</li> </ul> <p>\u00d3timalidade:</p> <ul> <li>A* \u00e9 \u00f3timo se a heur\u00edstica for admiss\u00edvel e consistente.</li> <li>Best-First e Hill Climbing n\u00e3o garantem a \u00f3timalidade.</li> </ul> <p>Completude:</p> <ul> <li>A* \u00e9 completo, enquanto Best-First e Hill Climbing podem falhar em encontrar uma solu\u00e7\u00e3o.</li> </ul> <p>Uso de Mem\u00f3ria:</p> <ul> <li>A* e Best-First podem usar uma quantidade significativa de mem\u00f3ria para armazenar n\u00f3s.</li> <li>Hill Climbing usa pouca mem\u00f3ria, pois n\u00e3o mant\u00e9m um hist\u00f3rico de estados.</li> </ul> <p>Aplica\u00e7\u00f5es:</p> <ul> <li>A* \u00e9 geralmente preferido quando uma solu\u00e7\u00e3o \u00f3tima \u00e9 necess\u00e1ria.</li> <li>Best-First \u00e9 \u00fatil quando a velocidade \u00e9 mais importante do que a precis\u00e3o.</li> <li>Hill Climbing \u00e9 usado para otimiza\u00e7\u00f5es locais, onde o espa\u00e7o de estados \u00e9 muito grande para explorar completamente.</li> </ul> <p>Escolher o algoritmo certo depende fortemente do problema espec\u00edfico que voc\u00ea est\u00e1 tentando resolver, das garantias que voc\u00ea precisa (completude, \u00f3timalidade), e dos recursos dispon\u00edveis (tempo, mem\u00f3ria).</p>"},{"location":"search_algorithms/#consideracoes-gerais","title":"Considera\u00e7\u00f5es Gerais","text":""},{"location":"search_algorithms/#aplicabilidade","title":"Aplicabilidade:","text":"<p>A escolha do tipo de algoritmo de busca a ser utilizado depende muito do tipo  de problema. Buscas cegas s\u00e3o mais gen\u00e9ricas e f\u00e1ceis de implementar, mas podem ser impratic\u00e1veis para espa\u00e7os de estados muito grandes. Buscas informadas s\u00e3o  geralmente prefer\u00edveis quando se tem um bom conhecimento do dom\u00ednio do  problema.</p>"},{"location":"search_algorithms/#recursos-computacionais","title":"Recursos Computacionais:","text":"<p>Algoritmos de busca podem ser intensivos em termos de tempo e mem\u00f3ria, o que \u00e9  uma considera\u00e7\u00e3o importante em aplica\u00e7\u00f5es em tempo real ou em dispositivos com  recursos limitados.</p>"},{"location":"search_algorithms/#heuristicas","title":"Heur\u00edsticas:","text":"<p>Em buscas informadas, a sele\u00e7\u00e3o de uma boa heur\u00edstica \u00e9 crucial.  Uma heur\u00edstica inadequada pode fazer com que o algoritmo funcione mal,  enquanto uma boa heur\u00edstica pode resolver o problema de forma muito eficiente.</p> <p>Em resumo, algoritmos de busca s\u00e3o uma ferramenta fundamental em IA para a  resolu\u00e7\u00e3o de problemas, e a compreens\u00e3o dos diferentes tipos e suas  aplica\u00e7\u00f5es pode fornecer insights valiosos na escolha da estrat\u00e9gia de  resolu\u00e7\u00e3o de problemas mais adequada.</p> <p></p>"},{"location":"search_algorithms/#um-algoritmo-de-busca-nao-discutido-em-sala-de-aula","title":"Um algoritmo de busca n\u00e3o discutido em sala de aula","text":"<p>Ambos os algoritmos comentados abaixo s\u00e3o de busca cega.</p>"},{"location":"search_algorithms/#dijkstra","title":"Dijkstra","text":"<p>Um algoritmo relacionado aos mencionados acima \u00e9 o Dijkstra, que \u00e9 um algoritmo de busca de caminho mais curto. Ele \u00e9 um algoritmo de busca em grafos que serve  para encontrar o caminho mais curto entre um n\u00f3 inicial e todos os outros n\u00f3s  em um grafo ponderado e dirigido. Importante notar que os pesos das arestas devem ser n\u00e3o-negativos para que o algoritmo funcione corretamente.</p> <p>Vale lembrar que o algoritmo A* \u00e9 uma varia\u00e7\u00e3o do algoritmo de Dijkstra que usa heur\u00edsticas para encontrar o caminho mais curto. Ou seja, Dijkstra \u00e9 um A* sem heur\u00edsticas, ou seja, n\u00e3o informado sobre o ambiente.</p> <pre><code>import heapq\n\ndef dijkstra(graph, start, goal):\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    queue = [(0, start)]\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance &gt; distances[current_node]:\n            continue\n\n        if current_node == goal:\n            return current_distance\n\n        for neighbor, weight in graph[current_node].items():\n            distance = current_distance + weight\n\n            if distance &lt; distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n# Exemplo de uso\ngraph = {'A': {'B': 1, 'C': 4}, 'B': {'A': 1, 'D': 2}, 'C': {'A': 4, 'E': 3}, 'D': {'B': 2}, 'E': {'C': 3, 'F': 5}, 'F': {'E': 5}}\nprint(dijkstra(graph, 'A', 'F'))  # Output: 9\n</code></pre>"},{"location":"search_algorithms/#bellman-ford","title":"Bellman-Ford","text":"<p>Outro algoritmo parecido com Dijkstra que tamb\u00e9m vale mencionar \u00e9 o Bellman-Ford que tamb\u00e9m \u00e9 um algoritmo de busca de caminho mais curto, por\u00e9m ele funciona mesmo quando as arestas possuem pesos negativos. Por\u00e9m, ele \u00e9 mais lento que o Dijkstra.</p> <pre><code>def bellman_ford(graph, start, end):\n    distance = {node: float('inf') for node in graph}\n    distance[start] = 0\n\n    for _ in range(len(graph) - 1):\n        for node in graph:\n            for neighbour, cost in graph[node].items():\n                if distance[node] + cost &lt; distance[neighbour]:\n                    distance[neighbour] = distance[node] + cost\n\n    for node in graph:\n        for neighbour, cost in graph[node].items():\n            if distance[node] + cost &lt; distance[neighbour]:\n                print(\"Graph contains a negative weight cycle\")\n                return None\n\n    return distance[end]\n\n# Exemplo de uso\ngraph = {'A': {'B': -1, 'C':  4},\n         'B': {'C':  3, 'D':  2, 'E':  2},\n         'C': {},\n         'D': {'B':  1, 'C':  5},\n         'E': {'D': -3}}\nprint(bellman_ford(graph, 'A', 'E'))  # Output: 1 (seguindo o caminho A -&gt; B -&gt; E)\n</code></pre>"},{"location":"search_algorithms/#comparacao-entre-dijkstra-e-bellman-ford","title":"Compara\u00e7\u00e3o entre Dijkstra e Bellman-Ford:","text":"<ul> <li> <p>Dijkstra: Mais r\u00e1pido para grafos sem arestas negativas, mas falha na presen\u00e7a de pesos negativos.</p> </li> <li> <p>Bellman-Ford: Mais lento, mas mais vers\u00e1til, j\u00e1 que pode lidar com arestas negativas e detectar ciclos negativos.</p> </li> </ul>"},{"location":"search_algorithms/#bibliografia","title":"Bibliografia","text":"<p>https://edisciplinas.usp.br/pluginfile.php/4848799/mod_resource/content/3/2019-ProblemasComoBusca-BuscaCega.pdf</p> <p>https://www.ime.usp.br/~cris/mac5711/slides/aula14.pdf</p> <p>https://www.youtube.com/watch?v=788_MGOgNA4</p> <p>https://www.youtube.com/watch?v=3cuOA-mxaHg</p> <p>https://www.youtube.com/watch?v=DlE2C0TTxqk</p> <p>https://theory.stanford.edu/~amitp/GameProgramming/AStarComparison.html</p> <p>https://www.geeksforgeeks.org/what-are-the-differences-between-bellman-fords-and-dijkstras-algorithms/</p>"},{"location":"state-of-the-art/","title":"Estado da arte, Benef\u00edcios e Riscos","text":"<p>One Hundred Year Study on Artificial Intelligence (AI100) da universidade de Stanford, nos Estados Unidos: O estado da arte da Intelig\u00eancia Artificial (IA) ainda est\u00e1 envolto em muitas quest\u00f5es n\u00e3o resolvidas, assim como o debate sobre a natureza da consci\u00eancia humana.</p> <p></p> <p>Mesmo com avan\u00e7os significativos em \u00e1reas como aprendizado de m\u00e1quina e redes neurais profundas, ainda n\u00e3o chegamos a um consenso sobre o que realmente constitui uma \"intelig\u00eancia\" similar \u00e0 humana. Em termos de engenharia de software, isso apresenta desafios como a modularidade e a escalabilidade, especialmente quando se trata de implementar IA em sistemas cr\u00edticos.</p> <p>Al\u00e9m disso, a integra\u00e7\u00e3o de m\u00faltiplas fontes de dados e a utiliza\u00e7\u00e3o de algoritmos complexos para tomada de decis\u00e3o trazem quest\u00f5es sobre a \"caixa-preta\" de IA, ou seja, a dificuldade de interpretar como exatamente as decis\u00f5es s\u00e3o tomadas por modelos de aprendizado profundo. Isso \u00e9 um gargalo tanto em termos de debug como de \u00e9tica, onde a accountability e a transpar\u00eancia s\u00e3o cruciais. As novas abordagens em IA, como modelos generativos e m\u00e9todos de aprendizado por refor\u00e7o, est\u00e3o moldando o progresso futuro, mas ainda estamos longe de ter um framework unificado que possa ser considerado uma IA verdadeiramente inteligente e consciente.</p>"}]}