{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Intelig\u00eancia Artificial","text":"<pre><code>Aluno: Filipe Santana Machado\n\nMatr\u00edcula: 180016563\n</code></pre>"},{"location":"#sobre-o-portfolio","title":"\ud83d\udd0e Sobre o portfolio","text":"<pre><code>Este projeto \u00e9 um estudo sobre os assuntos de intelig\u00eancia artificial,\nministrado como uma disciplina na Universidade de Bras\u00edlia.\n</code></pre>"},{"location":"#comentarios","title":"Coment\u00e1rios","text":"<p>Irei deixar coment\u00e1rios sobre cada sess\u00e3o utilizando o seguinte formato:</p> <p>Este \u00e9 um texto sobre um ponto adicional do qual eu gostaria de adicionar sobre o assunto descrito acima; Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nullam euismod, nisl sed lacinia ultricies, nunc nisl.</p>"},{"location":"#topicos","title":"T\u00f3picos","text":"<ul> <li>Entrega 1<ul> <li>O que \u00e9 Intelig\u00eancia Artificial?</li> <li>Hist\u00f3ria da Intelig\u00eancia Artificial</li> <li>Estado da Arte</li> <li>Agentes</li> </ul> </li> <li>Entrega 2 (Resolvendo problemas por Busca)<ul> <li>Agentes de Solu\u00e7\u00f5es de Problemas</li> <li>Algoritmos de Busca</li> <li>Fun\u00e7\u00f5es Heur\u00edsticas</li> <li>Busca em ambientes complexos</li> <li>Algoritmos gen\u00e9ticos</li> <li>Discuss\u00f5es</li> <li>Projetos e problemas</li> </ul> </li> <li>Entrega 3<ul> <li>Problemas de Satisfa\u00e7\u00e3o de Condi\u00e7\u00f5es (CSPs)</li> </ul> </li> <li>Entrega 4<ul> <li>Agentes baseados em Conhecimento</li> </ul> </li> </ul>"},{"location":"agent/","title":"Agentes e ambientes","text":"<p>Quando criamos um programa que possui algum n\u00edvel de intelig\u00eancia artificial precisamos que ele tome decis\u00f5es baseadas em algum ambiente. No caso, esse programa acaba se tornando um agente, por tormar a\u00e7\u00f5es/decis\u00f5es.</p>"},{"location":"agent/#tipos-de-agentes","title":"Tipos de agentes","text":"<p>No assunto que estamos abordando, temos dois tipos de agentes:</p> <ul> <li>Agente Inteligente</li> <li>Agente Racional</li> </ul>"},{"location":"agent/#agente-inteligente","title":"Agente Inteligente","text":"<p>Das caracter\u00edsticas que formam um agente inteligente:</p> <p>\u00c9 esperado que um agente ineligente seja aut\u00f4nomo quanto suas decis\u00f5es, ou seja, ele deve ser capaz de tomar decis\u00f5es sem a interven\u00e7\u00e3o humana.</p> <p>\u00c9 necess\u00e1rio que ele consiga perceber o ambiente em que est\u00e1 atuando e que consiga tomar decis\u00f5es baseadas nessa percep\u00e7\u00e3o.</p> <p>Persista por um per\u00edodo de tempo prolongado, para que consiga aprender e reter esse conhecimento para tomar decis\u00f5es futuras. Quanto mais conhecimento \u00fatil um agente possui, mais inteligente ele \u00e9, desde que tenha distin\u00e7\u00e3o se o conhecimento \u00e9 obsoleto ou n\u00e3o, ou se o conhecimento est\u00e1 errado de alguma forma.</p> <p>Tamb\u00e9m \u00e9 esperado que esse agente adapte-se a mudan\u00e7as no ambiente. Combinando as caracter\u00edsticas descritas acima, o agente consegue mudar seu comportamento para se adaptar a mudan\u00e7as no ambiente e melhorar seu resultado.</p> <p>Um agente inteligente tamb\u00e9m deve ser capaz de criar e buscar objetivos, ou seja, ele deve ser capaz de definir o que \u00e9 um objetivo e como alcan\u00e7\u00e1-lo.</p> <p>Esse \u00faltimo ponto sobre criar e buscar objetivos \u00e9 algo que me chama aten\u00e7\u00e3o, pois n\u00e3o \u00e9 algo totalmente aut\u00eantico em intelig\u00eancias artificiais, visto que n\u00f3s humanos possuimos objetivos que s\u00e3o definidos por n\u00f3s mesmos, no caso, por desejo pr\u00f3rio. J\u00e1 uma intelig\u00eancia artificial, por mais que seja capaz de definir objetivos, esses objetivos s\u00e3o definidos por um humano, ou seja, n\u00e3o \u00e9 algo aut\u00eantico.</p> <p>Tamb\u00e9m \u00e9 question\u00e1vel se em algum momento na hist\u00f3ria uma intelig\u00eancia conseguir\u00e1 criar desejos pr\u00f3prios, de forma totalmente aut\u00eantica.</p>"},{"location":"agent/#agente-racional","title":"Agente Racional","text":"<p>O agente racional tem como objetivo atingir resultados \u00f3timos, ou se imposs\u00edvel de obter um resultado \u00f3timo devido a limita\u00e7\u00f5es, ele busca obter um resultado o mais pr\u00f3ximo poss\u00edvel do melhor resultado. Essa forma de buscar um resultado \u00e9 baseada na racionalidade.</p>"},{"location":"agent/#racionalidade","title":"Racionalidade","text":"<p>A racionalidade de m\u00e1quinas \u00e9 um padr\u00e3o matem\u00e1ticamente definido pois usa a l\u00f3gica para tomar decis\u00f5es, e a l\u00f3gica por si s\u00f3 \u00e9 matem\u00e1tica. A abordagem de racionalidade \u00e9 mais suscet\u00edvel ao desenvolvimento cient\u00edfico pois n\u00e3o leva em conta cren\u00e7as e pseudo-ci\u00eancias humanas, e sim resultados comprovados sobre o objetivo alcan\u00e7ado.</p> <p>Devido \u00e0 abordagem comum para se desenvolver uma intelig\u00eancia artificial ser a racionalidade, \u00e9 comum, mas n\u00e3o exclusivo, que as intelig\u00eancias artificiais busquem reproduzir o comportamento mais l\u00f3gico poss\u00edvel, e n\u00e3o o comportamento mais humano poss\u00edvel. Por ser mais comum, essa abordagem constitui o Modelo Padr\u00e3o de intelig\u00eancia artificial.</p>"},{"location":"agent/#consequencialismo-e-medida-de-performance","title":"Consequencialismo e Medida de Performance","text":"<p>Um agente racional ir\u00e1 tomar decis\u00f5es baseadas em consequ\u00eancias, ou seja, buscar boas consequ\u00eancias ao inv\u00e9s das m\u00e1s consequ\u00eancias. Para isso, \u00e9 necess\u00e1rio que o agente seja capaz de medir a performance de suas a\u00e7\u00f5es, para que possa tomar decis\u00f5es baseadas nessa medida. Essa medida de performance \u00e9 chamada de fun\u00e7\u00e3o de utilidade, e isso \u00e9 inserido no programa pelo programador, de forma explicita ou implicita. Por exemplo, um programa que joga xadr\u00eaz pode ter como fun\u00e7\u00e3o de utilidade o n\u00famero de pe\u00e7as que ele possui no tabuleiro.</p> <p>Em meus estudos de aprendizado de m\u00e1quina, conheci essa fun\u00e7\u00e3o de utilidade  como o c\u00e1lculo do gradiente estoc\u00e1stico descendente, que \u00e9 uma forma de medir o qu\u00e3o bom \u00e9 o resultado de uma a\u00e7\u00e3o para que em seguida o agente tome decis\u00f5es a fim de achar um resultado \u00f3timo local esperando que fosse o resultado \u00f3timo global.</p>"},{"location":"agent/#especificando-o-ambiente-de-tarefas","title":"Especificando o ambiente de tarefas","text":"<p>Essa parte trata de projetar um agente racional especificando o ambiente trabalhado da forma mais completa poss\u00edvel. Para isso, podemos utilizar a descri\u00e7\u00e3o PEAS (Performance, Environment, Actuators, Sensors).</p>"},{"location":"agent/#peas","title":"PEAS","text":""},{"location":"agent/#performance","title":"Performance","text":"<p>Define a medida de performance desejada.</p>"},{"location":"agent/#environment","title":"Environment","text":"<p>Define o ambiente em que o agente ir\u00e1 atuar.</p>"},{"location":"agent/#actuators","title":"Actuators","text":"<p>Define as a\u00e7\u00f5es que o agente pode tomar.</p>"},{"location":"agent/#sensors","title":"Sensors","text":"<p>Define como o agente ir\u00e1 perceber o ambiente.</p> <p>Por exemplo, se o agente for um carro aut\u00f4nomo, a medida de performance pode ser a dist\u00e2ncia percorrida, a velocidade atingida, o n\u00edvel de seguran\u00e7a, e o consumo de gasolina. O ambiente pode ser uma pista de corrida, pedestres, outros carros e o clima. Quanto aos atuadores podem ser o volante, acelerador, marcha, freio e buzina. J\u00e1 os sensores podem ser c\u00e2meras, sensores de dist\u00e2ncia e um GPS.</p>"},{"location":"agent/#arquitetura-do-agente","title":"Arquitetura do Agente","text":"<p>A arquitetura do agente \u00e9 composta de um computador que possui sensores e atuadores.</p>"},{"location":"agent/#tipos-de-agente","title":"Tipos de Agente","text":""},{"location":"agent/#representacao-de-estados","title":"Representa\u00e7\u00e3o de Estados","text":"<p>A representa\u00e7\u00e3o Atomica \u00e9 a mais simples, onde cada estado \u00e9 representado por um \u00fanico valor onde estados s\u00e3o descritos com um \u00fanico valor at\u00f4mico, ou seja, n\u00e3o decompon\u00edvel. Quando falamos da representa\u00e7\u00e3o Fatorada, falamos que um estado pode possuir atributos que fazem parte desse estado, por exemplo, um estado pode ser representado por um conjunto de atributos como posi\u00e7\u00e3o, velocidade e dire\u00e7\u00e3o. J\u00e1 a representa\u00e7\u00e3o Estruturada, \u00e9 uma representa\u00e7\u00e3o mais complexa pois n\u00e3o possui apenas atributos, como tamb\u00e9m pode possuir objetos e esses objetos podem possuir rela\u00e7\u00f5es entre si.</p> <p>Em quest\u00e3o de complexidade, podemos dizer que a representa\u00e7\u00e3o atomica \u00e9 mais simples enquanto a representa\u00e7\u00e3o estruturada \u00e9 mais complexa e mais expressiva.</p> <pre><code>graph LR\n    A[Representa\u00e7\u00e3o Atomica] --&gt; B[Representa\u00e7\u00e3o Fatorada] --&gt; C[Representa\u00e7\u00e3o Estruturada]</code></pre>"},{"location":"complex_environments/","title":"Busca em ambientes complexos","text":""},{"location":"complex_environments/#busca-em-ambientes-complexos","title":"Busca em Ambientes Complexos","text":""},{"location":"complex_environments/#definicao-do-problema","title":"Defini\u00e7\u00e3o do Problema","text":"<p>A busca em ambientes complexos \u00e9 uma sub\u00e1rea cr\u00edtica da intelig\u00eancia artificial  (IA), cuja relev\u00e2ncia abrange desde simula\u00e7\u00f5es computacionais at\u00e9 sistemas de  otimiza\u00e7\u00e3o em tempo real. Diversas caracter\u00edsticas distinguem um ambiente  complexo, incluindo um grande espa\u00e7o de estados, incerteza nas vari\u00e1veis de  entrada, din\u00e2mica temporal e multifatorialidade nos objetivos.</p>"},{"location":"complex_environments/#caracteristicas-dos-ambientes-complexos","title":"Caracter\u00edsticas dos Ambientes Complexos","text":"<ol> <li> <p>Grande Espa\u00e7o de Estados: O conjunto de todas as configura\u00e7\u00f5es poss\u00edveis \u00e9 significativo, tornando invi\u00e1vel a busca exaustiva.</p> </li> <li> <p>Incerteza: Falta de informa\u00e7\u00f5es precisas sobre estados e transi\u00e7\u00f5es.</p> </li> <li> <p>Din\u00e2mica Temporal: O sistema ou ambiente pode mudar autonomamente com o tempo.</p> </li> <li> <p>Custo Computacional: A avalia\u00e7\u00e3o de um estado pode envolver c\u00e1lculos complexos.</p> </li> <li> <p>Multifatorialidade: M\u00faltiplos objetivos podem estar em jogo, muitas vezes conflitando entre si.</p> </li> </ol>"},{"location":"complex_environments/#tecnicas-de-busca-em-engenharia-de-software","title":"T\u00e9cnicas de Busca em Engenharia de Software","text":"<ul> <li> <p>Busca Informada: Emprega-se uma fun\u00e7\u00e3o heur\u00edstica para estimar o custo de um caminho do estado atual ao objetivo. O algoritmo A* \u00e9 frequentemente usado em tais cen\u00e1rios.</p> </li> <li> <p>Heur\u00edsticas Adaptativas: Em sistemas din\u00e2micos, as heur\u00edsticas podem ser ajustadas em tempo real para se adaptar \u00e0s novas condi\u00e7\u00f5es.</p> </li> <li> <p>Busca Local: Algoritmos como o gradiente descendente s\u00e3o usados para otimiza\u00e7\u00f5es localizadas e s\u00e3o particularmente \u00fateis quando o espa\u00e7o de busca \u00e9 cont\u00ednuo.</p> </li> <li> <p>Busca em \u00c1rvore: T\u00e9cnicas como o Monte Carlo Tree Search (MCTS) s\u00e3o \u00fateis para explorar espa\u00e7os de estados grandes de forma estruturada.</p> </li> <li> <p>Busca com Incerteza: Utiliza-se de m\u00e9todos estoc\u00e1sticos e teoria das decis\u00f5es para gerar estrat\u00e9gias \u00f3timas ou sub-\u00f3timas sob incerteza.</p> </li> </ul>"},{"location":"complex_environments/#desafios-e-implicacoes-para-a-engenharia-de-software","title":"Desafios e Implica\u00e7\u00f5es para a Engenharia de Software","text":"<ol> <li> <p>Explos\u00e3o Combinat\u00f3ria: O aumento exponencial do espa\u00e7o de estados exige t\u00e9cnicas de poda e paralelismo para melhorar a efici\u00eancia.</p> </li> <li> <p>Planejamento sob Incerteza: Incorporar modelos de incerteza para otimiza\u00e7\u00e3o de decis\u00f5es requer abordagens como programa\u00e7\u00e3o din\u00e2mica estoc\u00e1stica.</p> </li> <li> <p>Otimiza\u00e7\u00e3o em Tempo Real: O tempo de execu\u00e7\u00e3o \u00e9 uma restri\u00e7\u00e3o cr\u00edtica, necessitando de algoritmos de busca que possam fornecer solu\u00e7\u00f5es em um tempo vi\u00e1vel.</p> </li> <li> <p>Conflito de Objetivos: T\u00e9cnicas de otimiza\u00e7\u00e3o multiobjetivo, como Pareto Front, s\u00e3o necess\u00e1rias para resolver problemas com m\u00faltiplos objetivos conflitantes.</p> </li> </ol>"},{"location":"complex_environments/#conclusao","title":"Conclus\u00e3o","text":"<p>A busca em ambientes complexos \u00e9 uma \u00e1rea em r\u00e1pido desenvolvimento com  implica\u00e7\u00f5es diretas na engenharia de software. O dom\u00ednio apresenta desafios  \u00fanicos em termos de efici\u00eancia computacional, qualidade da solu\u00e7\u00e3o e  adaptabilidade a ambientes din\u00e2micos e incertos. O sucesso na solu\u00e7\u00e3o desses  problemas envolve a aplica\u00e7\u00e3o integrada de v\u00e1rias estrat\u00e9gias de busca,  cada uma com suas pr\u00f3prias vantagens, limita\u00e7\u00f5es e custos computacionais  associados.</p>"},{"location":"complex_environments/#bibliografia","title":"Bibliografia","text":"<p>https://edisciplinas.usp.br/pluginfile.php/7340740/mod_resource/content/1/IAPos_NA06.pdf</p> <p>https://edisciplinas.usp.br/pluginfile.php/4848799/mod_resource/content/3/2019-ProblemasComoBusca-BuscaCega.pdf</p> <p>https://edisciplinas.usp.br/pluginfile.php/4183182/mod_resource/content/1/Aula1V2017.pdf</p>"},{"location":"csp/","title":"Problemas de Satisfa\u00e7\u00e3o de Condi\u00e7\u00f5es (CSPs)","text":""},{"location":"csp/#impressoes-iniciais","title":"Impress\u00f5es iniciais","text":"<p>Como engenheiro de software, voc\u00ea provavelmente j\u00e1 se deparou com problemas  complexos que envolvem v\u00e1rias condi\u00e7\u00f5es e restri\u00e7\u00f5es. Nesse contexto, os  Problemas de Satisfa\u00e7\u00e3o de Restri\u00e7\u00f5es (CSPs) s\u00e3o extremamente relevantes.</p> <p>Imagine que voc\u00ea est\u00e1 desenvolvendo um sistema de agendamento.  H\u00e1 v\u00e1rias vari\u00e1veis em jogo: as disponibilidades de tempo, os recursos  necess\u00e1rios, as prefer\u00eancias dos usu\u00e1rios, entre outros.  Aqui, cada vari\u00e1vel (X) representa um elemento desse sistema - por exemplo,  um intervalo de tempo espec\u00edfico ou um recurso. Cada uma dessas vari\u00e1veis tem  um dom\u00ednio (D), que \u00e9 o conjunto de valores poss\u00edveis que ela pode assumir.  Por exemplo, o dom\u00ednio de um intervalo de tempo pode ser as horas do dia  durante as quais uma sala est\u00e1 dispon\u00edvel.</p> <p>Agora, as restri\u00e7\u00f5es (C) s\u00e3o as condi\u00e7\u00f5es que determinam como essas vari\u00e1veis  podem ser combinadas. Por exemplo, uma sala n\u00e3o pode ser reservada para dois  eventos diferentes ao mesmo tempo. O desafio em CSPs \u00e9 encontrar uma  atribui\u00e7\u00e3o para todas as vari\u00e1veis que satisfa\u00e7a todas essas restri\u00e7\u00f5es.</p> <p>Resolver CSPs pode ser complexo, especialmente quando temos muitas vari\u00e1veis e  restri\u00e7\u00f5es. Uma abordagem \u00e9 usar backtracking, que \u00e9 um tipo de pesquisa em  profundidade. Basicamente, voc\u00ea tenta uma solu\u00e7\u00e3o, e se encontrar um conflito,  volta atr\u00e1s (backtrack) e tenta uma abordagem diferente.  \u00c9 um m\u00e9todo poderoso, mas pode ser ineficiente para problemas muito grandes.</p> <p>Outras t\u00e9cnicas incluem algoritmos de consist\u00eancia local, que tentam reduzir o  tamanho do problema eliminando valores que n\u00e3o podem fazer parte de uma solu\u00e7\u00e3o  v\u00e1lida. Tamb\u00e9m temos heur\u00edsticas de pesquisa, como a busca com propaga\u00e7\u00e3o de  restri\u00e7\u00f5es, que tentam antecipar e resolver conflitos antes que eles ocorram.</p> <p>Em resumo, os CSPs s\u00e3o uma ferramenta poderosa em IA e ci\u00eancia da computa\u00e7\u00e3o,  ajudando-nos a lidar com problemas complexos onde v\u00e1rias condi\u00e7\u00f5es e restri\u00e7\u00f5es  precisam ser satisfeitas simultaneamente. Eles s\u00e3o aplic\u00e1veis em uma variedade  de campos, desde planejamento e agendamento at\u00e9 design de circuitos e jogos.  Como engenheiros de software, entender e aplicar CSPs pode nos ajudar a criar  solu\u00e7\u00f5es mais eficientes e eficazes para problemas complexos.</p>"},{"location":"csp/#representacao-atomica-vs-fatorada","title":"Representa\u00e7\u00e3o At\u00f4mica vs Fatorada","text":"<p>A representa\u00e7\u00e3o at\u00f4mica de um estado \u00e9 similar a uma representa\u00e7\u00e3o de caixa  preta, ou seja, n\u00e3o temos informa\u00e7\u00f5es sobre suas propriedades e componentes internos. Quando temos uma representa\u00e7\u00e3o mais complexa e expressiva, temos uma representa\u00e7\u00e3o fatorada, onde temos acesso aos atributos de um estado.</p> <pre><code>graph TD\n    subgraph \"Representa\u00e7\u00e3o At\u00f4mica\"\n        A[Estado at\u00f4mico A] --&gt; B[Estado At\u00f4mico B] --&gt; C[Estado At\u00f4mico C]\n    end\n\n\n    subgraph \"Representa\u00e7\u00e3o Fatorada\"\n        subgraph Estado_A\n            F[Estado fatorado A]\n            F --&gt;|Detalhe 1| J[Propriedade 1]\n            F --&gt;|Detalhe 2| K[Propriedade 2]\n            F --&gt;|Detalhe 3| I[Propriedade 3]\n        end\n\n        subgraph Estado_B\n            X[Estado fatorado A]\n            X --&gt;|Detalhe 1| Y[Propriedade 1]\n            X --&gt;|Detalhe 2| Z[Propriedade 2]\n            X --&gt;|Detalhe 3| L[Propriedade 3]\n        end\n\n        Estado_A ---&gt; Estado_B\n\n    end</code></pre> <p>Ao trabalhar com CSPs, iremos dar \u00eanfase a representa\u00e7\u00e3o fatorada do estados  pois precisamos ter uma vis\u00e3o mais granular sobre o problema, e tendo a  possibilidade de quebrar o problema em subproblemas facilita a encontrar a solu\u00e7\u00e3o.</p>"},{"location":"csp/#definindo-problemas-de-satisfacao-de-condicoes","title":"Definindo Problemas de Satisfa\u00e7\u00e3o de Condi\u00e7\u00f5es","text":"<p>A id\u00e9ia principal de usar uma CSP se baseia em achar uma solu\u00e7\u00e3o eliminando grandes por\u00e7\u00f5es do espa\u00e7o de busca ao identificar condi\u00e7\u00f5es neste espa\u00e7o de busca que impossibilitam o resultado.</p> <p>Em termos mais t\u00e9cnicos, um CSPs s\u00e3o tipicamente definidas por tr\u00eas  componentes:</p> <ul> <li>Vari\u00e1veis (X): Um conjunto finito de vari\u00e1veis que precisam ser resolvidas.</li> <li>Dom\u00ednios (D): Um conjunto finito de valores que as vari\u00e1veis podem assumir.</li> <li>Restri\u00e7\u00f5es (C): Um conjunto de condi\u00e7\u00f5es que as solu\u00e7\u00f5es devem satisfazer.</li> </ul> <p>Tendo definido isso, podemos dizer que CSPs lidam com atribui\u00e7\u00f5es de valores \u00e0s vari\u00e1veis. - Quando uma atribui\u00e7\u00e3o n\u00e3o viola nenhuma restri\u00e7\u00e3o, ela \u00e9 chamada de consistente; - Quando todas as vari\u00e1veis recebem um valor, a atribui\u00e7\u00e3o \u00e9 completa; - Quando nem todas as vari\u00e1veis recebem um valor, a atribui\u00e7\u00e3o \u00e9 parcial;</p> <p>Ent\u00e3o para definir uma solu\u00e7\u00e3o, precisamos que ela seja  consistente e completa. Logo, uma solu\u00e7\u00e3o parcial \u00e9 aquela que \u00e9 completa por\u00e9m nem todas as vari\u00e1veis s\u00e3o atribuias a algum valor. Solu\u00e7\u00f5es de CSP s\u00e3o problemas NP-Completo em geral.</p>"},{"location":"csp/#tipos-de-condicoes","title":"Tipos de Condi\u00e7\u00f5es","text":""},{"location":"csp/#condicoes-necessarias","title":"Condi\u00e7\u00f5es necess\u00e1rias","text":"<p>Iremos dar \u00eanfase aos seguintes tipos de condi\u00e7\u00f5es:</p> <ul> <li>Un\u00e1rias</li> <li>Bin\u00e1ria</li> <li>Alta Ordem (Tern\u00e1ria+)</li> <li>Global</li> </ul>"},{"location":"csp/#restricoes-unarias","title":"Restri\u00e7\u00f5es Un\u00e1rias","text":"<ul> <li>Conceito: As restri\u00e7\u00f5es un\u00e1rias s\u00e3o as mais simples em CSPs.  Elas afetam uma \u00fanica vari\u00e1vel.</li> <li>Exemplo: Uma restri\u00e7\u00e3o que especifica que uma vari\u00e1vel ( X ) deve  ser maior que 5.</li> </ul>"},{"location":"csp/#restricoes-binarias","title":"Restri\u00e7\u00f5es Bin\u00e1rias","text":"<ul> <li>Conceito: As restri\u00e7\u00f5es bin\u00e1rias envolvem duas vari\u00e1veis e estabelecem  uma rela\u00e7\u00e3o entre elas.</li> <li>Exemplo: Uma restri\u00e7\u00e3o que exige que duas vari\u00e1veis ( X ) e  ( Y ) sejam diferentes entre si.</li> </ul>"},{"location":"csp/#restricoes-de-alta-ordem-ternaria","title":"Restri\u00e7\u00f5es de Alta Ordem (Tern\u00e1ria+)","text":"<ul> <li>Conceito: As restri\u00e7\u00f5es de alta ordem envolvem tr\u00eas ou mais vari\u00e1veis. Elas s\u00e3o mais complexas que as un\u00e1rias e bin\u00e1rias e permitem expressar rela\u00e7\u00f5es entre grupos de muitas vari\u00e1veis.</li> <li>Exemplo: Uma restri\u00e7\u00e3o que determina que a soma das vari\u00e1veis ( X, Y, ) e ( Z ) deve ser igual a um valor espec\u00edfico.</li> </ul>"},{"location":"csp/#restricoes-globais","title":"Restri\u00e7\u00f5es Globais","text":"<ul> <li>Conceito: As restri\u00e7\u00f5es globais afetam um grande n\u00famero de vari\u00e1veis, \u00e0s  vezes todas em um CSP.  Elas s\u00e3o \u00fateis para expressar condi\u00e7\u00f5es abrangentes que envolvem m\u00faltiplas  vari\u00e1veis.</li> <li>Exemplo: Uma restri\u00e7\u00e3o de que todas as vari\u00e1veis em um conjunto devem  ter valores diferentes, como na regra do Sudoku, onde cada n\u00famero deve  aparecer apenas uma vez em cada linha, coluna e bloco.</li> </ul> <p>Qualquer uma dessas condi\u00e7\u00f5es de CSP podem ser reduzidas a condi\u00e7\u00f5es bi\u00e1rias.</p>"},{"location":"csp/#condicoes-de-preferencia","title":"Condi\u00e7\u00f5es de prefer\u00eancia","text":"<p>Ao contr\u00e1rio das condi\u00e7\u00f5es necess\u00e1rias, que s\u00e3o obrigat\u00f3rias para resolu\u00e7\u00e3o do CSP, as condi\u00e7\u00f5es de prefer\u00eancia servem para encontrarmos uma solu\u00e7\u00e3o preferida.</p> <p>Por exemplo:</p> <p>Em um jogo onde um mago precisa atravessar o campo de batalha, ele tem diversos caminhos para escolher que satisfazem as condi\u00e7\u00f5es que o mago ir\u00e1 chegar ao outro lado do campo vivo e sem atacar nenhum aliado. Mas o mago pode preferir ir por um caminho onde ele enfrente o m\u00e1ximo de inimigos,  ou ent\u00e3o pode preferir ir por um caminho onde h\u00e1 mais esp\u00f3lios, ou ent\u00e3o pode preferir ir por um caminho onde ele perca o m\u00ednimo de vida poss\u00edvel. Isso tudo s\u00e3o prefer\u00eancias, e n\u00e3o uma condi\u00e7\u00e3o obrigat\u00f3ria.</p>"},{"location":"csp/#propagacao-de-condicao","title":"Propaga\u00e7\u00e3o de condi\u00e7\u00e3o","text":"<p>Para ocorrer a propaga\u00e7\u00e3o de condi\u00e7\u00f5es, um algoritmo CSP reduz o dom\u00ednio de valores que uma vari\u00e1vel pode assumir, que pode reduzir o dom\u00ednio de outra vari\u00e1vel e assim sucessivamente. O objetivo de propaga\u00e7\u00e3o de condi\u00e7\u00f5es \u00e9 garantir a consist\u00eancia local.</p> <p>Para explicar o par\u00e1grafo acima, iremos explicar como ocorre o funcionamento da propaga\u00e7\u00e3o de condi\u00e7\u00f5es em CSPs:</p>"},{"location":"csp/#funcionamento","title":"Funcionamento","text":"<p>Redu\u00e7\u00e3o de Dom\u00ednio: Inicialmente, cada vari\u00e1vel em um CSP tem um  conjunto de poss\u00edveis valores que pode assumir (seu dom\u00ednio). Quando  uma restri\u00e7\u00e3o \u00e9 aplicada, o dom\u00ednio de uma vari\u00e1vel pode ser reduzido.  Por exemplo, se temos uma vari\u00e1vel ( X ) com um dom\u00ednio de {1, 2, 3, 4, 5} e uma restri\u00e7\u00e3o un\u00e1ria ( X &gt; 2 ), o dom\u00ednio de ( X ) \u00e9 reduzido para  {3, 4, 5}.</p> <p>Efeito Cascata: Esta redu\u00e7\u00e3o pode ter um efeito cascata. Considerando  uma restri\u00e7\u00e3o bin\u00e1ria entre ( X ) e ( Y ), a altera\u00e7\u00e3o no dom\u00ednio de  ( X ) pode levar a uma redu\u00e7\u00e3o no dom\u00ednio de ( Y ). Por exemplo, se  ( Y ) deve ser diferente de ( X ) e o novo dom\u00ednio de ( X ) \u00e9 {3, 4, 5},  ent\u00e3o os valores correspondentes s\u00e3o removidos do dom\u00ednio de ( Y ).</p> <p>Consist\u00eancia Local: O objetivo da propaga\u00e7\u00e3o \u00e9 alcan\u00e7ar a  consist\u00eancia local. Isso significa que para cada vari\u00e1vel e suas restri\u00e7\u00f5es  diretas (com outras vari\u00e1veis), existe pelo menos uma atribui\u00e7\u00e3o v\u00e1lida que  satisfaz as restri\u00e7\u00f5es.</p>"},{"location":"csp/#impacto-no-desenvolvimento-de-software","title":"Impacto no Desenvolvimento de Software","text":"<p>Para um engenheiro de software, a quest\u00e3o de propaga\u00e7\u00e3o de condi\u00e7\u00f5es pode ter as seguintes import\u00e2ncias:</p> <ul> <li> <p>Otimiza\u00e7\u00e3o de Algoritmos: Utilizar a propaga\u00e7\u00e3o de condi\u00e7\u00f5es em CSPs pode significar a diferen\u00e7a entre um algoritmo que resolve problemas em tempo h\u00e1bil e um que n\u00e3o \u00e9 vi\u00e1vel para uso pr\u00e1tico.</p> </li> <li> <p>Complexidade Computacional: A propaga\u00e7\u00e3o eficaz de condi\u00e7\u00f5es pode reduzir drasticamente o espa\u00e7o de busca, diminuindo a complexidade computacional do problema.</p> </li> <li> <p>Aplica\u00e7\u00f5es Pr\u00e1ticas: Em sistemas de agendamento, planejamento de recursos, ou em solu\u00e7\u00f5es de problemas l\u00f3gicos como Sudoku, a propaga\u00e7\u00e3o de condi\u00e7\u00f5es \u00e9 uma t\u00e9cnica essencial para garantir solu\u00e7\u00f5es eficientes.</p> </li> </ul> <p>Em resumo, a propaga\u00e7\u00e3o de condi\u00e7\u00f5es em CSPs \u00e9 uma t\u00e9cnica fundamental para  qualquer engenheiro de software envolvido na solu\u00e7\u00e3o de problemas complexos que  requerem otimiza\u00e7\u00e3o e efici\u00eancia. Ela n\u00e3o s\u00f3 reduz o espa\u00e7o de busca, como  tamb\u00e9m assegura a consist\u00eancia local das solu\u00e7\u00f5es, dois aspectos cruciais para a  efici\u00eancia dos sistemas que desenvolvemos e mantemos.</p>"},{"location":"csp/#consistencia","title":"Consist\u00eancia","text":""},{"location":"csp/#consistencia-de-no","title":"Consist\u00eancia de N\u00f3","text":"<p>A consist\u00eancia de nodo ocorre quando todas as restri\u00e7\u00f5es un\u00e1rias s\u00e3o  satisfeitas. Isso significa que cada vari\u00e1vel individualmente deve satisfazer  as restri\u00e7\u00f5es que lhe s\u00e3o impostas. \u00c9 o tipo mais b\u00e1sico de consist\u00eancia e  geralmente \u00e9 o ponto de partida para algoritmos de CSP. Envolve a verifica\u00e7\u00e3o e  a adequa\u00e7\u00e3o dos dom\u00ednios de vari\u00e1veis individuais para atender a restri\u00e7\u00f5es  un\u00e1rias.</p>"},{"location":"csp/#consistencia-de-arco","title":"Consist\u00eancia de Arco","text":"<p>Um arco entre duas vari\u00e1veis (X) e (Y) \u00e9 consistente se, para cada valor no  dom\u00ednio de (X), existe algum valor no dom\u00ednio de (Y) que satisfa\u00e7a a  restri\u00e7\u00e3o entre (X) e (Y). \u00c9 crucial em CSPs com restri\u00e7\u00f5es bin\u00e1rias.  Algoritmos como o AC-3 (Algorithm for Arc Consistency) s\u00e3o usados para alcan\u00e7ar  a consist\u00eancia de arco, removendo valores dos dom\u00ednios das vari\u00e1veis que n\u00e3o  podem participar de solu\u00e7\u00f5es v\u00e1lidas.</p>"},{"location":"csp/#consistencia-de-trajeto","title":"Consist\u00eancia de Trajeto","text":"<p>Um CSP \u00e9 dito trajeto consistente se, para cada trio de vari\u00e1veis, todas as  combina\u00e7\u00f5es de valores que satisfazem as restri\u00e7\u00f5es bin\u00e1rias entre elas s\u00e3o  compat\u00edveis com as restri\u00e7\u00f5es terci\u00e1rias aplic\u00e1veis. \u00c9 mais complexa e menos  comum que a consist\u00eancia de nodo e arco. Envolve a considera\u00e7\u00e3o de trios de  vari\u00e1veis e \u00e9 \u00fatil em CSPs onde as rela\u00e7\u00f5es entre tr\u00eas vari\u00e1veis s\u00e3o cruciais.</p>"},{"location":"csp/#consistencia-global","title":"Consist\u00eancia Global","text":"<p>Um CSP \u00e9 globalmente consistente se, para cada subconjunto de vari\u00e1veis e para  cada atribui\u00e7\u00e3o poss\u00edvel a esse subconjunto que satisfaz as restri\u00e7\u00f5es sobre  ele, \u00e9 poss\u00edvel estender essa atribui\u00e7\u00e3o ao resto das vari\u00e1veis sem violar  nenhuma restri\u00e7\u00e3o. \u00c9 o tipo mais forte de consist\u00eancia, mas tamb\u00e9m o mais  dif\u00edcil de alcan\u00e7ar e verificar. Geralmente, n\u00e3o \u00e9 pr\u00e1tico verificar a  consist\u00eancia global para problemas grandes, mas \u00e9 um objetivo desej\u00e1vel.</p>"},{"location":"csp/#consistencia-k-k-consistency","title":"Consist\u00eancia K (k-Consistency)","text":"<p>Um CSP \u00e9 k-consistente se para qualquer conjunto de (k-1) vari\u00e1veis e uma  atribui\u00e7\u00e3o consistente a essas vari\u00e1veis, a extens\u00e3o dessa atribui\u00e7\u00e3o a uma  k-\u00e9sima vari\u00e1vel \u00e9 consistente com as restri\u00e7\u00f5es do CSP. A consist\u00eancia k  oferece um meio-termo entre a simplicidade da consist\u00eancia de n\u00f3/arco e a  complexidade da consist\u00eancia global. A consist\u00eancia 2, por exemplo, \u00e9  equivalente \u00e0 consist\u00eancia de arco.</p>"},{"location":"csp/#algoritmos","title":"Algoritmos","text":""},{"location":"csp/#backtracking","title":"Backtracking","text":"<p>\u00c9 o algoritmo mais b\u00e1sico e direto para resolver CSPs. Ele tenta atribuir  valores a cada vari\u00e1vel sequencialmente e volta atr\u00e1s (backtrack) quando uma  restri\u00e7\u00e3o \u00e9 violada. Utilizado em problemas de CSP mais simples e \u00e9 a base para  muitos outros algoritmos mais sofisticados.</p>"},{"location":"csp/#exemplo-em-python","title":"Exemplo em Python:","text":"<pre><code>def backtrack(assignment, csp):\n    # Verifica se a atribui\u00e7\u00e3o est\u00e1 completa\n    if len(assignment) == len(csp.variables):\n        return assignment\n\n    # Seleciona uma vari\u00e1vel ainda n\u00e3o atribu\u00edda\n    var = select_unassigned_variable(assignment, csp)\n\n    # Testa todos os valores poss\u00edveis para a vari\u00e1vel\n    for value in csp.domains[var]:\n        # Checa se a atribui\u00e7\u00e3o atual \u00e9 consistente com as restri\u00e7\u00f5es do CSP\n        if is_consistent(var, value, assignment, csp):\n            assignment[var] = value  # Atribui o valor \u00e0 vari\u00e1vel\n            result = backtrack(assignment, csp)  # Continua recursivamente\n            if result:\n                return result  # Retorna a solu\u00e7\u00e3o, se encontrada\n            assignment.pop(var)  # Caso contr\u00e1rio, remove a atribui\u00e7\u00e3o e tenta outra\n\n    return False  # Retorna False se nenhuma atribui\u00e7\u00e3o v\u00e1lida for encontrada\n</code></pre>"},{"location":"csp/#algoritmo-de-arc-consistency-ac-3","title":"Algoritmo de Arc Consistency (AC-3)","text":"<p>AC-3 \u00e9 um algoritmo para alcan\u00e7ar a consist\u00eancia de arco em CSPs. Ele examina  sistematicamente pares de vari\u00e1veis e elimina valores inconsistentes dos seus  dom\u00ednios. Comumente usado como um pr\u00e9-processamento em CSPs para reduzir o  espa\u00e7o de busca antes de aplicar algoritmos como backtracking.</p>"},{"location":"csp/#exemplo-em-python_1","title":"Exemplo em Python:","text":"<pre><code>def ac3(csp):\n    # Inicializa a fila com todos os arcos do CSP\n    queue = [(Xi, Xj) for Xi in csp.variables for Xj in csp.neighbors[Xi]]\n\n    # Processa cada arco na fila\n    while queue:\n        Xi, Xj = queue.pop(0)  # Remove um arco da fila\n\n        # Revisa o arco e atualiza o dom\u00ednio de Xi se necess\u00e1rio\n        if revise(csp, Xi, Xj):\n            if not csp.domains[Xi]:\n                return False  # Retorna False se o dom\u00ednio de Xi ficar vazio\n\n            # Adiciona novamente \u00e0 fila todos os arcos que afetam Xi\n            for Xk in csp.neighbors[Xi]:\n                if Xk != Xj:\n                    queue.append((Xk, Xi))\n\n    return True  # Retorna True se todos os arcos forem consistentes\n\ndef revise(csp, Xi, Xj):\n    \"\"\"Revisa o dom\u00ednio de Xi para garantir consist\u00eancia com Xj.\n\n    Args:\n        csp: O problema de CSP, contendo vari\u00e1veis, dom\u00ednios e restri\u00e7\u00f5es.\n        Xi: A vari\u00e1vel cujo dom\u00ednio est\u00e1 sendo revisado.\n        Xj: A vari\u00e1vel vizinha de Xi.\n\n    Returns:\n        True se houver alguma revis\u00e3o no dom\u00ednio de Xi, False caso contr\u00e1rio.\n    \"\"\"\n    revised = False\n    for x in csp.domains[Xi][:]:  # Copia do dom\u00ednio para evitar modificar durante itera\u00e7\u00e3o\n        # Se n\u00e3o existe nenhum valor em Xj que satisfa\u00e7a a restri\u00e7\u00e3o com x, remove x do dom\u00ednio de Xi\n        if not any(is_satisfied(x, y, csp.constraints[Xi, Xj]) for y in csp.domains[Xj]):\n            csp.domains[Xi].remove(x)\n            revised = True\n    return revised\n\ndef is_satisfied(x, y, constraint):\n    \"\"\"Verifica se a restri\u00e7\u00e3o entre x e y \u00e9 satisfeita.\n\n    Args:\n        x: Valor da vari\u00e1vel Xi.\n        y: Valor da vari\u00e1vel Xj.\n        constraint: A restri\u00e7\u00e3o entre Xi e Xj.\n\n    Returns:\n        True se a restri\u00e7\u00e3o \u00e9 satisfeita, False caso contr\u00e1rio.\n    \"\"\"\n    # Implementa\u00e7\u00e3o espec\u00edfica da restri\u00e7\u00e3o\n    pass\n</code></pre>"},{"location":"csp/#min-conflicts","title":"Min-conflicts","text":"<p>Um algoritmo de busca local que seleciona uma vari\u00e1vel que est\u00e1 em conflito e  muda seu valor para minimizar o n\u00famero de conflitos.  Particularmente eficaz em problemas com uma grande densidade de restri\u00e7\u00f5es.  \u00c9 \u00fatil em CSPs de grande escala onde uma solu\u00e7\u00e3o \u00f3tima n\u00e3o \u00e9 necess\u00e1ria, mas  uma solu\u00e7\u00e3o \"boa o suficiente\" \u00e9 aceit\u00e1vel.</p>"},{"location":"csp/#exemplo-em-python_2","title":"Exemplo em Python:","text":"<pre><code>import random\n\ndef min_conflicts(csp, max_steps=1000):\n    def conflicts(var, value):\n        # Conta o n\u00famero de conflitos se 'var' for atribu\u00eddo a 'value'\n        return sum(1 for neighbor in csp.neighbors[var] if value == csp.assignment[neighbor])\n\n    for _ in range(max_steps):\n        # Identifica todas as vari\u00e1veis que est\u00e3o em conflito\n        conflicted = [var for var in csp.variables if conflicts(var, csp.assignment[var]) &gt; 0]\n\n        # Se n\u00e3o h\u00e1 conflitos, a solu\u00e7\u00e3o atual \u00e9 retornada\n        if not conflicted:\n            return csp.assignment\n\n        # Escolhe aleatoriamente uma vari\u00e1vel em conflito\n        var = random.choice(conflicted)\n\n        # Escolhe o valor para 'var' que minimiza o n\u00famero de conflitos\n        value = min(csp.domains[var], key=lambda val: conflicts(var, val))\n\n        # Atribui o valor escolhido a 'var'\n        csp.assignment[var] = value\n\n    return None  # Retorna None se nenhuma solu\u00e7\u00e3o for encontrada dentro do limite de passos\n\n# Nota: Este \u00e9 um exemplo conceitual. A implementa\u00e7\u00e3o real exigiria uma estrutura de dados CSP mais detalhada.\n</code></pre>"},{"location":"csp/#estrutura-de-problemas","title":"Estrutura de Problemas","text":"<p>Arvore de Busca e Pruning: Utilizando \u00e1rvores de busca para representar o  espa\u00e7o de busca, podemos dizer que os algoritmos de CSP s\u00e3o mais eficientes que os algoritmos de procura tradicionais, pois eles conseguem realizar podas eficientes na \u00e1rvore de busca. Algoritmos de CSP s\u00e3o eficientes em  identificar e descartar ramos da \u00e1rvore de busca que n\u00e3o podem levar a  solu\u00e7\u00f5es v\u00e1lidas. Isso \u00e9 feito por meio da verifica\u00e7\u00e3o de restri\u00e7\u00f5es: se uma  atribui\u00e7\u00e3o parcial viola uma restri\u00e7\u00e3o, n\u00e3o h\u00e1 necessidade de explorar mais  adiante nesse ramo.</p> <p>A afirma\u00e7\u00e3o de que \"algoritmos baseados em CSPs s\u00e3o, na pr\u00e1tica, mais eficientes que algoritmos de procura tradicionais\" pode ser considerada  correta em muitos contextos, especialmente em rela\u00e7\u00e3o \u00e0 capacidade desses  algoritmos de realizar podas eficientes na \u00e1rvore de busca, como no exemplo  do problema de colora\u00e7\u00e3o do mapa da Austr\u00e1lia. Vamos analisar a afirma\u00e7\u00e3o em  detalhes:</p> <p>Compara\u00e7\u00e3o com Procura Tradicional: Em algoritmos de busca tradicionais, como busca em profundidade ou largura, todas as poss\u00edveis combina\u00e7\u00f5es teriam  que ser exploradas de maneira mais uniforme, sem a vantagem de eliminar op\u00e7\u00f5es  com base na viola\u00e7\u00e3o de restri\u00e7\u00f5es.</p> <p>Portanto, \u00e9 correto dizer que os algoritmos de CSP, ao  aplicarem restri\u00e7\u00f5es de maneira eficaz, podem ser mais eficientes do que  m\u00e9todos de busca tradicionais, especialmente em problemas onde as restri\u00e7\u00f5es  desempenham um papel crucial na defini\u00e7\u00e3o de solu\u00e7\u00f5es v\u00e1lidas. Essa efici\u00eancia em CSPs \u00e9 particularmente not\u00e1vel em problemas complexos e de  grande escala, onde a habilidade de reduzir rapidamente o espa\u00e7o de busca \u00e9  essencial para encontrar solu\u00e7\u00f5es em um tempo razo\u00e1vel.</p>"},{"location":"csp/#discussoes","title":"Discuss\u00f5es","text":"<p>Um algoritmo n\u00e3o discutido em sala de aula, e que \u00e9 relacionado aos algoritmos discutidos, temos o AC-6:</p>"},{"location":"csp/#algoritmo-ac-6","title":"Algoritmo AC-6","text":"<p>O AC-3 e o AC-6 s\u00e3o algoritmos projetados para impor a consist\u00eancia de arco em  problemas de satisfa\u00e7\u00e3o de restri\u00e7\u00f5es (CSPs), mas diferem em efici\u00eancia e  complexidade. O AC-3, mais simples de implementar, revisa todos os arcos que  incidem sobre uma vari\u00e1vel cada vez que um valor \u00e9 removido de seu dom\u00ednio, o  que pode levar a revis\u00f5es repetitivas e desnecess\u00e1rias. Em contraste, o AC-6,  mais complexo na implementa\u00e7\u00e3o, utiliza estruturas de dados auxiliares para  rastrear especificamente quais valores s\u00e3o consistentes entre as vari\u00e1veis,  reduzindo assim o n\u00famero total de revis\u00f5es. Isso torna o AC-6 geralmente mais  r\u00e1pido do que o AC-3, especialmente em CSPs com uma grande quantidade de  restri\u00e7\u00f5es e dom\u00ednios extensos, pois minimiza o trabalho redundante e melhora a  efici\u00eancia global do processo de busca por consist\u00eancia.</p> <p>Implementar o algoritmo AC-6 \u00e9 consideravelmente mais complexo do que AC-3  devido \u00e0 necessidade de manter estruturas de dados adicionais para rastrear as  rela\u00e7\u00f5es de suporte entre os valores das vari\u00e1veis. No entanto, posso fornecer  um esqueleto de como o algoritmo AC-6 seria estruturado em Python, com  coment\u00e1rios que explicam cada parte do processo.</p> <p>Simplificando o algoritmo AC-6, ele funciona da seguinte maneira... Exemplo em  python:</p> <p><pre><code>class AC6:\n    def __init__(self, csp):\n        self.csp = csp  # CSP problem with variables, domains, and constraints\n        self.queue = []  # Queue of arcs\n        self.supports = {}  # Support structure to keep track of consistent values\n\n    def initialize(self):\n        # Initialize the support structure and queue\n        for xi in self.csp.variables:\n            for xj in self.csp.neighbors[xi]:\n                for a in self.csp.domains[xi]:\n                    # Initialize supports to keep track of values in xj's domain that are consistent with a\n                    self.supports[(xi, a, xj)] = set(val for val in self.csp.domains[xj] if self.csp.is_consistent(xi, a, xj, val))\n                    if not self.supports[(xi, a, xj)]:\n                        self.csp.domains[xi].remove(a)\n                    if len(self.csp.domains[xi]) == 0:\n                        return False  # No solution exists\n                for b in self.csp.domains[xj]:\n                    if not any(self.csp.is_consistent(xi, a, xj, b) for a in self.csp.domains[xi]):\n                        self.queue.append((xj, xi, b))  # Add arc to queue if b has no support\n\n        return True\n\n    def revise(self, xi, xj, b):\n        # Revise the domain of xi based on the value b of xj\n        revised = False\n        for a in self.csp.domains[xi][:]:  # Iterate over a copy to allow removal\n            if b not in self.supports[(xi, a, xj)]:\n                self.csp.domains[xi].remove(a)  # Remove a if it is not supported by b\n                revised = True\n                if len(self.csp.domains[xi]) == 0:\n                    return False  # No solution exists\n        return revised\n\n    def run(self):\n        # Main loop of AC-6\n        if not self.initialize():\n            return False  # No solution exists\n\n        while self.queue:\n            xj, xi, b = self.queue.pop(0)\n            if self.revise(xi, xj, b):\n                for xk in self.csp.neighbors[xi]:\n                    for a in self.csp.domains[xk]:\n                        if a not in self.supports[(xk, a, xi)]:\n                            self.queue.append((xi, xk, a))  # Add arc to queue if a loses support\n\n        return True  # CSP is arc consistent\n</code></pre> Notem que este c\u00f3digo \u00e9 um esbo\u00e7o e n\u00e3o funcionar\u00e1 sem uma implementa\u00e7\u00e3o  completa das estruturas de dados de CSP e das fun\u00e7\u00f5es de verifica\u00e7\u00e3o de  consist\u00eancia. Em um sistema real, implementar o AC-6, exigiria uma compreens\u00e3o  profunda do problema de CSP em quest\u00e3o e uma implementa\u00e7\u00e3o detalhada das  restri\u00e7\u00f5es e da l\u00f3gica de suporte.</p>"},{"location":"csp/#projetos-e-problemas","title":"Projetos e problemas","text":""},{"location":"csp/#problema-de-agendamento-de-eventos","title":"Problema de agendamento de eventos","text":"<p>Imagine um problema onde temos v\u00e1rios eventos e temos que agendar esses eventos em um n\u00famero definido de salas dispon\u00edveis em uma universidade.  Cada evento tem um hor\u00e1rio de in\u00edcio e fim. Ent\u00e3o precisamos definir quais eventos ocorrer\u00e3o em quais salas.</p> <p>Para resolver esse problema, podemos usar algoritmos de CSP; Em modos pr\u00e1ticos podemos utilizar uma biblioteca Python chamada <code>python-constraint</code> a fim de definir vari\u00e1veis, dom\u00ednios e restri\u00e7\u00f5es.</p> <p>Essa biblioteca simplifica a confec\u00e7\u00e3o de um script que resolva uma CSP;  Utilizando os algoritmos de Backtracking, Recursive backtracking e Min-Conflits essa biblioteca resolve problemas de dom\u00ednios finitos.</p> <p>Para demonstrar a resolu\u00e7\u00e3o do problema, escrevi um script Python em portugu\u00eas com coment\u00e1rios em linha e Docstrings para deixar o mais expl\u00edcito poss\u00edvel o funcionamento do c\u00f3digo.</p> <p>O trecho de c\u00f3digo abaixo \u00e9 a parte principal da resolu\u00e7\u00e3o da CSP no projeto:</p> <pre><code>def resolver_agendamento(eventos, num_salas=4):\n    \"\"\"\n    Resolve o problema de agendamento de eventos em salas.\n\n    Args:\n        eventos (dict): Dicion\u00e1rio com os eventos e seus hor\u00e1rios.\n        num_salas (int): N\u00famero de salas dispon\u00edveis.\n\n    Returns:\n        dict: Dicion\u00e1rio com os eventos e seus hor\u00e1rios nas respectivas salas.\n    \"\"\"\n    problem = Problem()\n\n    # Adicionando eventos como vari\u00e1veis com seus dom\u00ednios (salas e hor\u00e1rios)\n    for evento, horario in eventos.items():\n        inicio, fim = horario\n        horarios_possiveis = [\n            (sala, (inicio, fim)) for sala in range(1, num_salas + 1)\n        ]\n        problem.addVariable(evento, horarios_possiveis)\n\n    # Adicionando restri\u00e7\u00e3o de n\u00e3o sobreposi\u00e7\u00e3o\n    for evento1 in eventos:\n        for evento2 in eventos:\n            if evento1 &lt; evento2:\n                problem.addConstraint(sem_sobreposicao, (evento1, evento2))\n\n    # Encontrando uma solu\u00e7\u00e3o\n    return problem.getSolution()\n</code></pre> <p>\u00c9 f\u00e1cil ver como a biblioteca simplifica a resolu\u00e7\u00e3o de CSPs. Para um engenheiro de software, em cen\u00e1rios de mundo real, o uso de bibliotecas que agilizam o desenvolvimento e permitem que o engenheiro se concentre mais na l\u00f3gica do problema do que na implementa\u00e7\u00e3o de algoritmos \u00e9 extremamente vantajoso.</p> <p>A restri\u00e7\u00e3o principal do problema \u00e9 que os eventos n\u00e3o podem ser sobrepostos.</p> <pre><code>def sem_sobreposicao(evento1, evento2):\n    \"\"\"\n    Verifica se dois eventos n\u00e3o est\u00e3o sobrepostos.\n\n    Args:\n        evento1 (tuple): Tupla com o nome do evento e seu hor\u00e1rio.\n        evento2 (tuple): Tupla com o nome do evento e seu hor\u00e1rio.\n\n    Returns:\n        bool: True se n\u00e3o h\u00e1 sobreposi\u00e7\u00e3o, False caso contr\u00e1rio.\n    \"\"\"\n    sala1, (inicio1, fim1) = evento1\n    sala2, (inicio2, fim2) = evento2\n    return sala1 != sala2 or fim1 &lt;= inicio2 or inicio1 &gt;= fim2\n</code></pre> <p>No reposit\u00f3rio do resposit\u00f3rio do presente documento, \u00e9 poss\u00edvel encontrar o c\u00f3digo na pasta <code>csp</code>. [Link para a pasta do projeto]</p> <p>Basta executar <code>python main.py</code> para ver o resultado do script. Utilizei <code>pygame</code> para renderizar o resultado do script em uma janela.</p> <p> </p> <p>O problema l\u00ea o arquivo json mais novo na pasta do algoritmo e calcula o resultado. Ent\u00e3o \u00e9 poss\u00edvel gerar novos problemas e resolver com o script. Basta executar <code>python generate_events.py</code> para gerar um novo json com as novas condi\u00e7\u00f5es de eventos.</p>"},{"location":"csp/#bibliografia","title":"Bibliografia","text":"<p>https://folivetti.github.io/courses/IA/PDF/Aula04.pdf</p> <p>https://en.wikipedia.org/wiki/AC-3_algorithm</p> <p>https://www.cs.cmu.edu/~arielpro/15381f16/c_slides/781f16-3.pdf</p> <p>https://www.cs.ubc.ca/~kevinlb/teaching/cs322%20-%202009-10/Lectures/CSP3.pdf</p> <p>https://ktiml.mff.cuni.cz/~bartak/constraints/stochastic.html</p> <p>https://www.slideserve.com/asis/maintaining-arc-consistency-ac-6-powerpoint-ppt-presentation</p> <p>https://www.researchgate.net/publication/220565739_Propositional_Satisfiability_and_Constraint_Programming_A_comparative_survey</p> <p>https://pypi.org/project/python-constraint/</p>"},{"location":"genetic_algorithms/","title":"Algoritmos gen\u00e9ticos","text":""},{"location":"genetic_algorithms/#algoritmos-geneticos-uma-perspectiva-para-engenharia-de-software","title":"Algoritmos Gen\u00e9ticos: Uma Perspectiva para Engenharia de Software","text":""},{"location":"genetic_algorithms/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>Os Algoritmos Gen\u00e9ticos (AGs) s\u00e3o uma classe de algoritmos de otimiza\u00e7\u00e3o e  busca inspirados na teoria da evolu\u00e7\u00e3o natural. Estes algoritmos s\u00e3o  especialmente \u00fateis em cen\u00e1rios onde o espa\u00e7o de busca \u00e9 grande, complexo e  mal-definido, sendo frequentemente empregados em problemas que v\u00e3o desde a  otimiza\u00e7\u00e3o de rotas at\u00e9 a engenharia de caracter\u00edsticas em sistemas de  software.</p>"},{"location":"genetic_algorithms/#fundamentos-e-operacao","title":"Fundamentos e Opera\u00e7\u00e3o","text":"<ol> <li>Inicia\u00e7\u00e3o da Popula\u00e7\u00e3o: Um conjunto inicial de solu\u00e7\u00f5es candidatas \u00e9 gerado aleatoriamente.</li> <li>Sele\u00e7\u00e3o: Solu\u00e7\u00f5es s\u00e3o avaliadas com base em uma fun\u00e7\u00e3o de aptid\u00e3o.</li> <li>Crossover (Recombina\u00e7\u00e3o): Pares de solu\u00e7\u00f5es s\u00e3o combinados para criar novas solu\u00e7\u00f5es.</li> <li>Muta\u00e7\u00e3o: Altera\u00e7\u00f5es aleat\u00f3rias s\u00e3o introduzidas em algumas solu\u00e7\u00f5es.</li> <li>Avalia\u00e7\u00e3o e Substitui\u00e7\u00e3o: A nova gera\u00e7\u00e3o \u00e9 avaliada e as melhores solu\u00e7\u00f5es s\u00e3o mantidas.</li> </ol>"},{"location":"genetic_algorithms/#aplicacoes-na-engenharia-de-software","title":"Aplica\u00e7\u00f5es na Engenharia de Software","text":"<ul> <li>Teste de Software: AGs podem ser usados para gerar casos de teste que maximizem a cobertura do c\u00f3digo.</li> <li>Refatora\u00e7\u00e3o de C\u00f3digo: Os AGs podem otimizar a estrutura do c\u00f3digo para melhorar m\u00e9tricas como legibilidade e efici\u00eancia.</li> <li>Balanceamento de Carga: Em sistemas distribu\u00eddos, os AGs podem otimizar a aloca\u00e7\u00e3o de recursos.</li> </ul>"},{"location":"genetic_algorithms/#vantagens-e-limitacoes","title":"Vantagens e Limita\u00e7\u00f5es","text":"<ul> <li>Vantagens:</li> <li>Flexibilidade para abordar uma variedade de problemas.</li> <li>Capacidade de explorar um grande espa\u00e7o de busca.</li> <li> <p>Menos suscet\u00edvel a ficar preso em \u00f3timos locais.</p> </li> <li> <p>Limita\u00e7\u00f5es:</p> </li> <li>Converg\u00eancia para a solu\u00e7\u00e3o \u00f3tima n\u00e3o \u00e9 garantida.</li> <li>A fun\u00e7\u00e3o de aptid\u00e3o deve ser cuidadosamente projetada.</li> <li>Custos computacionais podem ser elevados para problemas de grande escala.</li> </ul>"},{"location":"genetic_algorithms/#consideracoes-tecnicas-e-desafios","title":"Considera\u00e7\u00f5es T\u00e9cnicas e Desafios","text":"<ol> <li>Paralelismo: A execu\u00e7\u00e3o de AGs pode ser paralelizada para melhorar a efici\u00eancia.</li> <li>Hiperpar\u00e2metros: A escolha de par\u00e2metros como taxa de crossover e muta\u00e7\u00e3o \u00e9 crucial.</li> <li>Escalabilidade: Em problemas de alta dimensionalidade, os AGs podem sofrer com quest\u00f5es de escalabilidade.</li> </ol>"},{"location":"genetic_algorithms/#conclusao","title":"Conclus\u00e3o","text":"<p>Os Algoritmos Gen\u00e9ticos oferecem um conjunto robusto de t\u00e9cnicas para  solucionar problemas de otimiza\u00e7\u00e3o e busca em engenharia de software.  No entanto, o sucesso na aplica\u00e7\u00e3o destes m\u00e9todos requer uma compreens\u00e3o  profunda tanto do problema em quest\u00e3o quanto dos pr\u00f3prios algoritmos.  Considera\u00e7\u00f5es sobre custo computacional, qualidade da solu\u00e7\u00e3o e ajuste de  hiperpar\u00e2metros s\u00e3o fundamentais para o emprego eficaz dos AGs em cen\u00e1rios  industriais.</p>"},{"location":"genetic_algorithms/#bibliografia","title":"Bibliografia","text":"<p>https://edisciplinas.usp.br/pluginfile.php/7340740/mod_resource/content/1/IAPos_NA06.pdf</p> <p>https://edisciplinas.usp.br/pluginfile.php/4848799/mod_resource/content/3/2019-ProblemasComoBusca-BuscaCega.pdf</p> <p>https://edisciplinas.usp.br/pluginfile.php/4183182/mod_resource/content/1/Aula1V2017.pdf</p>"},{"location":"heuristics/","title":"Fun\u00e7\u00f5es Heur\u00edsticas","text":""},{"location":"heuristics/#o-que-sao-funcoes-heuristicas","title":"O que s\u00e3o Fun\u00e7\u00f5es Heur\u00edsticas?","text":"<p>Em termos simples, uma fun\u00e7\u00e3o heur\u00edstica \u00e9 como um atalho que ajuda o  computador a decidir qual op\u00e7\u00e3o \u00e9 \"provavelmente\" a melhor, sem ter que  calcular todas as op\u00e7\u00f5es em detalhes. Ela d\u00e1 uma esp\u00e9cie de \"nota\" para cada  op\u00e7\u00e3o, e a op\u00e7\u00e3o com a melhor \"nota\" \u00e9 geralmente escolhida.</p> <p>Imagine que voc\u00ea est\u00e1 jogando um jogo de tabuleiro e tem v\u00e1rias jogadas  poss\u00edveis. Voc\u00ea n\u00e3o tem tempo para pensar em todas as consequ\u00eancias de cada  movimento at\u00e9 o final do jogo, certo? Em vez disso, voc\u00ea faz um \"palpite  educado\" sobre qual movimento parece ser o melhor. Esse \"palpite educado\"  \u00e9 essencialmente o que uma fun\u00e7\u00e3o heur\u00edstica faz em  intelig\u00eancia artificial (IA).</p>"},{"location":"heuristics/#importancia","title":"Import\u00e2ncia","text":"<p>Fun\u00e7\u00f5es heur\u00edsticas s\u00e3o importantes porque tornam os algoritmos mais r\u00e1pidos.  Em muitos problemas, especialmente em IA, h\u00e1 muitas op\u00e7\u00f5es e possibilidades a  considerar. Calcular todas elas levaria muito tempo e recursos. Uma boa fun\u00e7\u00e3o  heur\u00edstica pode reduzir drasticamente esse esfor\u00e7o.</p>"},{"location":"heuristics/#exemplos-simples","title":"Exemplos Simples","text":"<ol> <li> <p>Jogo da Velha: Uma heur\u00edstica simples seria contar o n\u00famero de linhas,  colunas ou diagonais que est\u00e3o a um passo de serem completadas. Quanto mais  voc\u00ea tiver, melhor \u00e9 a posi\u00e7\u00e3o.</p> </li> <li> <p>Problema do Caminho Mais Curto: Se voc\u00ea quiser ir de uma cidade A para  uma cidade B, uma fun\u00e7\u00e3o heur\u00edstica pode ser a dist\u00e2ncia em linha reta entre A  e B. Essa \u00e9 uma boa estimativa do caminho mais curto poss\u00edvel.</p> </li> </ol>"},{"location":"heuristics/#como-sao-utilizadas","title":"Como s\u00e3o Utilizadas?","text":"<p>Em algoritmos como A* (A-star), as fun\u00e7\u00f5es heur\u00edsticas s\u00e3o usadas para  estimar o custo do caminho mais curto de um ponto a outro. O algoritmo usa  essa estimativa para priorizar quais caminhos explorar primeiro.</p>"},{"location":"heuristics/#limitacoes","title":"Limita\u00e7\u00f5es","text":"<ol> <li> <p>Precis\u00e3o: Uma fun\u00e7\u00e3o heur\u00edstica \u00e9 um palpite, ent\u00e3o pode estar errada.  Uma m\u00e1 heur\u00edstica pode at\u00e9 piorar o desempenho do algoritmo.</p> </li> <li> <p>Complexidade: Algumas fun\u00e7\u00f5es heur\u00edsticas podem ser complicadas de  calcular, anulando os benef\u00edcios de velocidade que oferecem.</p> </li> </ol>"},{"location":"heuristics/#resumo","title":"Resumo","text":"<p>Ent\u00e3o, uma fun\u00e7\u00e3o heur\u00edstica \u00e9 como um \"truque\" que ajuda os computadores a  tomar decis\u00f5es mais rapidamente. Elas s\u00e3o super \u00fateis em IA para tornar os  algoritmos mais eficientes, mas \u00e9 importante escolher a heur\u00edstica certa para  o problema que voc\u00ea est\u00e1 tentando resolver.</p>"},{"location":"heuristics/#contribuindo-para-o-assunto-de-heuristicas","title":"Contribuindo para o assunto de heur\u00edsticas","text":""},{"location":"heuristics/#distancia-de-manhattan","title":"Dist\u00e2ncia de Manhattan","text":"<p>Um exemplo de heur\u00edstica \u00e9 a dist\u00e2ncia de Manhattan, que \u00e9 a dist\u00e2ncia entre dois pontos em um grid, se deslocando apenas na horizontal e vertical. Essa heur\u00edstica foi comentada brevemente em sala de aula por\u00e9m \u00e9 interessante aprofundar um pouco mais sobre ela.</p> <p>A dist\u00e2ncia de Manhattan \u00e9 uma fun\u00e7\u00e3o heur\u00edstica comumente usada em problemas  que envolvem grade ou espa\u00e7o bidimensional, como encontrar o caminho mais curto em um labirinto.</p> <p>Implementei uma esp\u00e9cie de jogo para experimentar com diferentes tipos de algoritmos de busca. O jogo \u00e9 um labirinto onde o jogador deve encontrar o caminho mais curto para chegar ao objetivo. O c\u00f3digo est\u00e1 dispon\u00edvel no Github.</p> <p>Para o algoritmo A* no jogo, implementei usando a Manhattan Distance para estimar o custo do caminho mais curto.</p> <p></p>"},{"location":"heuristics/#o-que-e-distancia-de-manhattan","title":"O que \u00e9 Dist\u00e2ncia de Manhattan?","text":"<p>A dist\u00e2ncia de Manhattan entre dois pontos ( A ) e ( B ) em um plano \u00e9 a  soma das diferen\u00e7as absolutas de suas coordenadas. Por exemplo, se  ( A=(x_1, y_1) ) e ( B=(x_2, y_2) ), a dist\u00e2ncia de Manhattan seria  ( |x_1 - x_2| + |y_1 - y_2| ).</p>"},{"location":"heuristics/#como-e-utilizada-como-heuristica","title":"Como \u00e9 Utilizada como Heur\u00edstica?","text":"<p>Suponha que voc\u00ea est\u00e1 resolvendo um problema de labirinto em uma grade 2D e  quer encontrar o caminho mais curto de um ponto inicial a um ponto final.  Voc\u00ea pode usar a dist\u00e2ncia de Manhattan como uma fun\u00e7\u00e3o heur\u00edstica para estimar  o \"custo\" para chegar do ponto atual ao destino. O algoritmo de busca, como   A*, usaria essa estimativa para priorizar quais caminhos explorar.</p>"},{"location":"heuristics/#vantagens","title":"Vantagens","text":"<ol> <li>Simplicidade: \u00c9 f\u00e1cil de calcular.</li> <li>Efici\u00eancia: Ajuda o algoritmo de busca a focar nos caminhos mais  promissores, acelerando a solu\u00e7\u00e3o do problema.</li> </ol>"},{"location":"heuristics/#limitacoes_1","title":"Limita\u00e7\u00f5es","text":"<ol> <li>Admissibilidade: Em alguns casos, pode n\u00e3o ser a melhor estimativa para  o custo real. Por exemplo, se o movimento diagonal \u00e9 permitido, a dist\u00e2ncia de  Manhattan pode superestimar o custo.</li> <li>Aplicabilidade: \u00c9 mais \u00fatil em espa\u00e7os bidimensionais ou em problemas  que podem ser mapeados em uma grade 2D.</li> </ol>"},{"location":"heuristics/#exemplo-em-um-problema-de-caminho-mais-curto","title":"Exemplo em um Problema de Caminho Mais Curto","text":"<p>Suponha que o ponto inicial esteja na coordenada (2, 3) e o ponto final esteja  na coordenada (5, 6). A dist\u00e2ncia de Manhattan entre esses pontos seria  ( |5-2| + |6-3| = 3 + 3 = 6 ).</p> <p>O algoritmo usaria essa dist\u00e2ncia para estimar que o custo para ir do ponto  inicial ao ponto final \u00e9 de aproximadamente 6 unidades. Isso ajuda o algoritmo  a priorizar rotas que parecem mais curtas, economizando tempo e recursos  computacionais.</p> <p>Ent\u00e3o, em resumo, a dist\u00e2ncia de Manhattan \u00e9 uma heur\u00edstica popular e \u00fatil,  especialmente para problemas que envolvem grades ou espa\u00e7os bidimensionais.</p>"},{"location":"heuristics/#bibliografia","title":"Bibliografia","text":"<p>https://edisciplinas.usp.br/pluginfile.php/7340740/mod_resource/content/1/IAPos_NA06.pdf</p> <p>https://www.geeksforgeeks.org/a-search-algorithm/</p> <p>https://xlinux.nist.gov/dads/HTML/manhattanDistance.html#:~:text=Definition%3A%20The%20distance%20between%20two,y1%20%2D%20y2%7C.</p>"},{"location":"history/","title":"Hist\u00f3ria","text":""},{"location":"history/#1950-alan-turing-e-john-mccarthy","title":"1950 - Alan Turing e John McCarthy","text":"<p>Alan Turing \u00e9 considerado o pai da ci\u00eancia da computa\u00e7\u00e3o, e por ser um dos primeiros a considerar a intelig\u00eancia artificial como um assunto de computa\u00e7\u00e3o tamb\u00e9m \u00e9 comumente considerado o pai da mesma. Em 1950, Turing publicou um  artigo chamado \"Computing Machinery and Intelligence\" onde ele aborda um \"Jogo da Imita\u00e7\u00e3o\" e que para um humano venc\u00ea-lo consistentemente, ele teria que testar se estava conversando com uma m\u00e1quina usando o \"Teste de Turing\" que consistiria de perguntas cujo uma m\u00e1quina n\u00e3o conseguiria responder igual um humano.</p> <p>Hoje em dia Testes de Turing s\u00e3o muito utilizados com o prop\u00f3sito de  identificar e bloquear bots e acessos automatizados em sites.</p> <p>Esses testes s\u00e3o conhecidos como CAPTCHA (Completely Automated Public Turing test to tell Computers and Humans Apart).</p> <p>E esses CAPTCHAs precisam evoluir conforme as m\u00e1quinas tamb\u00e9m evoluem no quesito de intelig\u00eancia artificial. Em breve discutirei mais sobre esse assunto.</p> <p>J\u00e1 sobre o termo \"Intelig\u00eancia Artificial\" foi cunhado por John McCarthy,  do MIT, em 1955. O termo se referia \u00e0 constru\u00e7\u00e3o de um programa de computador que fosse capaz de realizar tarefas que normalmente era realizado por seres humanos e exigia processos mentais de alto n\u00edvel, onde h\u00e1 rela\u00e7\u00e3o de  aprendizado, mem\u00f3ria e racioc\u00ednio cr\u00edtico trabalhando em conjunto.</p> <p>Arthur Samuel, em 1956, utilizou a t\u00e9cnica de aprendizado por refor\u00e7o para ensinar computadores a jogar damas.</p>"},{"location":"history/#1950-matematica-e-xadrez","title":"1950+ - Matem\u00e1tica e Xadr\u00eaz","text":"<p>Em 1951, foi criado uma calculadora (SNARC) que era implementada usando um mecanismo similar a uma rede neural, essa calculadora se utilizava de um processo de tentativa e erro para aprender.</p> <p>Pr\u00f3ximo a 1960, um programa de computador chamado MANIAC  (Mathematical Analyzer, Numerical Integrator, and Computer or  Mathematical Analyzer, Numerator, Integrator, and Computer) foi desenvolvido e, por falta de poder computacional na \u00e9poca, era capaz de jogar uma varia\u00e7\u00e3o de xadr\u00eaz que contava com um tabuleiro de dimens\u00f5es 6x6  conhecido como Los Alamos Chess.</p> <p>Devido \u00e0 limita\u00e7\u00f5es de poder computacional, os estudos de intelig\u00eancia  artificial tiveram uma pequena pausa nesse per\u00edodo.</p>"},{"location":"history/#1970-inverno-da-ia","title":"1970 - Inverno da IA","text":"<p>Tivemos outro per\u00edodo de pausa da intelig\u00eancia artificial que ocorreu entre os anos 70 e o come\u00e7o dos anos 80. Esse per\u00edodo ficou conhecido como \"Inverno da IA\". Onde n\u00e3o existia muita novidade sobre o assunto e houveram muitos cortes nos investimentos da \u00e1rea.</p>"},{"location":"history/#1980-comercial","title":"1980+ - Comercial","text":"<p>Em 1980, devido \u00e0 evolu\u00e7\u00e3o do poder computacional, a intelig\u00eancia artificial voltou a ser um assunto de estudo e, nesse per\u00edodo, a intelig\u00eancia artificial come\u00e7ou a ser utilizada para fins comerciais. Os sistemas desenvolvidos nessa  \u00e9poca, foram os primeiros a serem reconhecidos como sistemas especialistas.</p> <p>Suas aplica\u00e7\u00f5es eram diversas e eles podiam desempenhar tarefas como an\u00e1lise de risco de cr\u00e9dico banc\u00e1rio, ger\u00eanciamento de riscos e at\u00e9 algoritmos de otimiza\u00e7\u00e3o de desempenho em negocia\u00e7\u00e3o de a\u00e7\u00f5es financeiras.</p>"},{"location":"history/#1990-internet-muitos-dados-e-aplicacoes-famosas","title":"1990 - Internet, muitos dados e aplica\u00e7\u00f5es famosas","text":""},{"location":"history/#internet","title":"Internet","text":"<p>Em 1990, a internet come\u00e7ou a se popularizar e com isso, a quantidade de dados dispon\u00edveis para serem processados aumentou exponencialmente.  Com isso, a intelig\u00eancia artificial come\u00e7ou a ser utilizada para processar esses dados e extrair informa\u00e7\u00f5es \u00fateis para os usu\u00e1rios e dos usu\u00e1rios.</p>"},{"location":"history/#guerra-do-golfo","title":"Guerra do Golfo","text":"<p>Em 1991, durante a Guerra do Golfo, os Estados Unidos da Am\u00e9rica utilizaram uma ferramenta chamada de Dynamic Analysis and Replanning Tool (DART) que era um sistema especialista que auxiliava os militares a planejar suas miss\u00f5es.</p> <p>Esse sistema especialista levava em considera\u00e7\u00e3o diversos fatores como condi\u00e7\u00f5es clim\u00e1ticas, condi\u00e7\u00f5es do terreno, condi\u00e7\u00f5es de tr\u00e1fego para poder prever rotas e recursos para se ganhar a guerra. Normalmente se levaria algumas semanas para planejar uma miss\u00e3o por m\u00e9todos tradicionais, por\u00e9m usando a DART isso foi poss\u00edvel em apenas algumas horas.</p>"},{"location":"history/#kasparov-vs-deep-blue","title":"Kasparov VS Deep Blue","text":"<p>Inicialmente os programas que eram capazes de jogar xadr\u00eaz conseguiam ganhar apenas no n\u00edvel amador e n\u00e3o eram capazes de vencer um jogador profissional. </p> <p>Deep Blue foi um programa de computador desenvolvido pela IBM que foi capaz de vencer o campe\u00e3o mundial de xadr\u00eaz, Garry Kasparov, em 1997.  Esse foi um marco hist\u00f3rico para a intelig\u00eancia artificial, pois foi a primeira vez que um programa de computador venceu um campe\u00e3o mundial de xadr\u00eaz.</p>"},{"location":"history/#2000-big-data","title":"2000 - Big Data","text":"<p>Com o aumento da quantidade de dados dispon\u00edveis, a intelig\u00eancia artificial come\u00e7ou a ser utilizada para processar esses dados e extrair informa\u00e7\u00f5es \u00fateis para os usu\u00e1rios e dos usu\u00e1rios. Tradicionalmente, os dados eram armazenados e processados usando SGBDs (Sistemas Gerenciadores de Banco de Dados) e processados usando SQL (Structured Query Language).</p> <p>O volume de dados come\u00e7ou a ser t\u00e3o grande que o armazenamento e poder de processamento das empresas (utilizando SGBDs) n\u00e3o era mais suficiente para  processar esses dados. Com isso, come\u00e7ou a surgir a ideia de armazenar esses dados em nuvem e utilizar o poder de processamento de outras empresas. Este conceito \u00e9 conhecido como \"Big Data\".</p> <p>A Big Data \u00e9 de suma import\u00e2ncia para treinamento de intelig\u00eancia artificiais hoje em dia, visto que hoje em dia \u00e9 poss\u00edvel utilizar esses dados que possuem um grande volume e uma grande variedade de dados para treinar algoritmos.</p>"},{"location":"history/#2010-deep-learning","title":"2010 - Deep Learning","text":"<p>Deep Learning \u00e9 uma sub-\u00e1rea do campo da intelig\u00eancia artificial que surgiu em meados de 2010. Essa \u00e1rea da intelig\u00eancia artificial alavancou os estudos sobre reconhecimento de imagens, processamento de linguagem natura,  reconhecimento de voz e muitas outras \u00e1reas.</p>"},{"location":"history/#opiniao-sobre-a-historia-da-ia","title":"Opini\u00e3o sobre a hist\u00f3ria da IA","text":"<p>Na minha opini\u00e3o, n\u00e3o h\u00e1 muito o que se adicionar sobre fatos hist\u00f3ricos que  ocorreram h\u00e1 muito tempo pois \u00e9 o que \u00e9. Por\u00e9m, \u00e9 interessante notar que a intelig\u00eancia artificial \u00e9 um assunto que j\u00e1 existe h\u00e1 muito tempo e que est\u00e1 em constante evolu\u00e7\u00e3o.</p> <p>Essa evolu\u00e7\u00e3o da IA vale a pena n\u00e3o s\u00f3 o  conhecimento e o aprendizado, mas tamb\u00e9m vale a discuss\u00e3o de como isso pode  afetar o futuro visto que estamos em um per\u00edodo pr\u00f3ximo ao que se pode considerar como uma revolu\u00e7\u00e3o das intelig\u00eancias artificiais, onde temos novos modelos de algoritmos capazes de realizar uma gama enorme fun\u00e7\u00f5es que humanos levam anos para aprender e horas ou dias para colocar uma atividade em pr\u00e1tica.</p> <p></p> <p>Um dos assuntos que me chama aten\u00e7\u00e3o \u00e9 sobre o CAPTCHA, e a preocupa\u00e7\u00e3o da gera\u00e7\u00e3o de novas formas de CAPTCHA, visto que hoje em dia a intelig\u00eancia artificial avan\u00e7ou a ponto de ser capaz de resolver CAPTCHAs com uma taxa de acerto melhor que humanos.</p> <p>Outro ponto sobre a rela\u00e7\u00e3o de CAPTCHA com intelig\u00eancia artificial \u00e9 que hoje em dia, os servi\u00e7os de CAPTCHA hoje em dia se utilizam de intelig\u00eancia artificial para gerar captchas e aprimorar modelos de reconhecimento de imagens.</p>"},{"location":"history/#veja-how-google-trains-ai-with-your-help-through-captcha","title":"Veja: How Google Trains AI with Your Help through CAPTCHA","text":""},{"location":"intro/","title":"Introdu\u00e7\u00e3o","text":""},{"location":"intro/#o-que-e-inteligencia-artificial","title":"O que \u00e9 Intelig\u00eancia Artificial?","text":"<p>O assunto \"intelig\u00eancia artificial\" come\u00e7a muito antes da ci\u00eancia da computa\u00e7\u00e3o existir. Hist\u00f3ricamente, existem mitos sobre uma intelig\u00eancia que n\u00e3o nasceu naturalmente, e sim, artificialmente. Como exemplos, podemos citar o mito grego  de Pigmale\u00e3o e o mito judaico-crist\u00e3o de Golem. Estes mitos falam sobre seres que foram criados e que possuem uma intelig\u00eancia similar a dos humanos. Ent\u00e3o quando falamos de intelig\u00eancia artificial, podemos dizer que se trata de uma intelig\u00eancia criada, apesar de que hoje em dia o termo \u00e9 comumente associado \u00e0 computa\u00e7\u00e3o. Por isso, vamos abordar o assunto com o foco na computa\u00e7\u00e3o.</p> <p>Apesar do nome conter a palavra \"intelig\u00eancia\", \u00e9 dif\u00edcil definir o que de fato \u00e9 uma intelig\u00eancia e tamb\u00e9m se um programa de computador pode possuir essa qualidade t\u00e3o qual um humano.</p>"},{"location":"intro/#fidelidade-a-performance-humana-x-racionalidade","title":"Fidelidade \u00e0 performance humana x Racionalidade","text":"<p>O ser humano nem sempre obt\u00e9m a resposta \u00f3tima, por\u00e9m \u00e9 capaz de obter uma resposta satisfat\u00f3ria que leva em considera\u00e7\u00f5es muitos aspectos do problema em quest\u00e3o. Contudo, o ser humano n\u00e3o \u00e9 100% racional, e acaba por muitas vezes tomando em considera\u00e7\u00e3o as emo\u00e7\u00f5es e sentimentos para tomar decis\u00f5es.</p> <p>J\u00e1 uma m\u00e1quina executa uma l\u00f3gica implementada em forma de algoritmo, a princ\u00edpio, sem tomar emo\u00e7\u00f5es em considera\u00e7\u00e3o.</p> <p>Acredito que a problem\u00e1tica nesse tema \u00e9 fazer uma m\u00e1quina conseguir tomar decis\u00f5es levando a racionalidade humana como base, por\u00e9m excluindo as emo\u00e7\u00f5es para se obter um resultado \u00f3timo, e n\u00e3o apenas replicar comportamento humano.</p>"},{"location":"intro/#raciocinio-x-comportamento","title":"Raciocinio x Comportamento","text":"<p>O racioc\u00ednio \u00e9 a capacidade de um ser de obter conclus\u00f5es l\u00f3gicas a partir de premissas. J\u00e1 o comportamento \u00e9 a forma como um ser age em determinadas situa\u00e7\u00f5es.</p> <p>A intelig\u00eancia artificial pode ser configurada para ambos os prop\u00f3sitos, dependendo do problema que se deseja resolver. As vezes queremos replicar  o comportamento humano para passar em um teste de turing, ou gerar uma imagem que pare\u00e7a pintada por um humano; Outrora precisamos de encontrar uma solu\u00e7\u00e3o \u00f3tima para o design de uma pe\u00e7a de um carro, ou para a rota de um caminh\u00e3o.</p> <p>Um exemplo para replicar comportamento humano poderia ser as imagens geradas por intelig\u00eancia artificial. Por exemplo as que s\u00e3o publicadas no site  Lexica.</p> <p>Outro exemplo, para otimiza\u00e7\u00e3o de designs de engenharia poderia ser os carros desenvolvidos por intelig\u00eancia artificial, como os apresentados no v\u00eddeo de Donut que buscam utilizar menos materiais, ser mais resistentes e mais r\u00e1pidos, feitos automaticamente por impressoras 3d.</p>"},{"location":"intro/#modelo-padrao","title":"Modelo Padr\u00e3o","text":"<p>Pode ser chamado, de Modelo Padr\u00e3o, o paradigma geral, dentro da \u00e1rea de intelig\u00eancia artificial, sobre o estudo de agentes que agem de forma correta, ou seja, de uma forma  racional esperada.</p>"},{"location":"intro/#fundamentos-da-inteligencia-artificial","title":"Fundamentos da Intelig\u00eancia Artificial","text":"<p>Os fundamentos da Intelig\u00eancia Artificial (IA) abrangem \u00e1reas como aprendizado de m\u00e1quina, l\u00f3gica simb\u00f3lica, redes neurais e tomada de decis\u00e3o baseada em  regras. Esses pilares s\u00e3o combinados para criar sistemas de IA que podem  realizar tarefas diversas, como reconhecimento de voz e classifica\u00e7\u00e3o de  imagens. O campo est\u00e1 em constante evolu\u00e7\u00e3o, com novas t\u00e9cnicas e modelos  sendo regularmente desenvolvidos para aprimorar o desempenho e a precis\u00e3o  desses sistemas. Tais tarefas realizadas por IA impactam nossa vida todo dia e a tend\u00eancia \u00e9 que essas tarefas se tornem cada vez mais presente para alterar a forma que trabalhamos e vivemos, facilitando e dando mais autonomia para os seres humanos.</p> <p>Enquanto a IA \u00e9, sem d\u00favida, uma conquista impressionante da engenharia de  software, n\u00e3o podemos ignorar seus desafios \u00e9ticos e t\u00e9cnicos. Por exemplo,  sistemas de IA treinados com dados enviesados podem perpetuar ou at\u00e9 mesmo  intensificar preconceitos existentes. Al\u00e9m disso, a \"caixa-preta\" de muitos  algoritmos de aprendizado profundo torna dif\u00edcil entender completamente  como as decis\u00f5es s\u00e3o tomadas, o que \u00e9 um problema s\u00e9rio em aplica\u00e7\u00f5es  cr\u00edticas, como diagn\u00f3stico m\u00e9dico ou sistemas judiciais. Como futuros  engenheiros de software, precisamos ser conscientes dessas quest\u00f5es ao  desenvolver e implementar novas tecnologias em IA.</p>"},{"location":"knowledge_based_agends/","title":"Agentes baseados em conhecimento","text":"<p>Agentes baseados em conhecimento s\u00e3o projetados para operar em dom\u00ednios  espec\u00edficos. Eles utilizam um vasto conjunto de conhecimentos sobre esse  dom\u00ednio para interpretar dados, resolver problemas e tomar decis\u00f5es. Esses conhecimentos sobre o dom\u00ednio se sintetizam em forma de uma base de  conhecimento que armazena fatos, regras, heur\u00edsticas e rela\u00e7\u00f5es que s\u00e3o  estruturados de forma que o agente possa acess\u00e1-la e interpret\u00e1-la  eficientemente utilizando regras de l\u00f3gica, utilizando racioc\u00ednio dedutivo, indutivo ou abdutivo.</p> <p>Explicando novamente:</p> <p>Podemos chamar essa base de conhecimento de knowledge base (KB) e essa base ir\u00e1 guardar senten\u00e7as que representam alguma informa\u00e7\u00e3o sobre o mundo. Essas senten\u00e7as devem ser capazes de ser aferidas logicamente.</p> <p>Quando uma senten\u00e7a na base de conhecimento n\u00e3o depende de outras senten\u00e7as, ou seja, \u00e9 uma senten\u00e7a independente, podemos chamar de axioma</p>"},{"location":"knowledge_based_agends/#tell-ask","title":"TELL &amp; ASK","text":"<p>Essa base de conhecimento \u00e9 mut\u00e1vel e deve ser capaz de adi\u00e7\u00e3o de novas seten\u00e7as. Comumente, essas opera\u00e7\u00f5es de adi\u00e7\u00e3o de senten\u00e7as pode ser chamada de TELL.</p> <p>Assim como podemos adicionar novas senten\u00e7as na base de conhecimento, devemos tamb\u00e9m ter a capacidade de consultar e aferir as senten\u00e7as. Essas opera\u00e7\u00f5es de consulta s\u00e3o comumente chamadas de ASK.</p> <p>Ambos os processos mencionados acima podem envolver infer\u00eancia, gerando novas senten\u00e7as derivando de senten\u00e7as antigas.</p>"},{"location":"knowledge_based_agends/#abordagens","title":"Abordagens","text":"<p>Temos duas abordagens para o desenvolvimento do agente baseado em conhecimento:</p> <ul> <li> <p>Abordagem declarativa: Quando uma base de conhecimento inicia-se vazia, e as seten\u00e7as s\u00e3o criadas em tempo de execu\u00e7\u00e3o, sendo inseridas por um  projetista.</p> </li> <li> <p>Abordagem procedural: Quando as senten\u00e7as e comportamentos desejados s\u00e3o inseridos diretamente no c\u00f3digo do programa.</p> </li> </ul>"},{"location":"knowledge_based_agends/#logica","title":"L\u00f3gica","text":"<p>Na l\u00f3gica, identificamos principalmente dois elementos:  A sintaxe e a sem\u00e2ntica.</p> <p>A sintaxe, um componente essencial do sistema lingu\u00edstico em uso, estabelece as  rela\u00e7\u00f5es entre os elementos de uma senten\u00e7a. Ela define a estrutura correta e a  forma de constru\u00e7\u00e3o das frases.</p> <p>Por outro lado, a sem\u00e2ntica se ocupa da interpreta\u00e7\u00e3o das senten\u00e7as. Dentro de  um contexto l\u00f3gico poss\u00edvel  (onde as senten\u00e7as n\u00e3o violam regras estabelecidas), a sem\u00e2ntica \u00e9 respons\u00e1vel  por determinar a veracidade das afirma\u00e7\u00f5es. </p> <p>Tomemos, por exemplo, a senten\u00e7a alfa ( \u03b1 ). Se em um modelo espec\u00edfico  M, \u03b1 \u00e9 considerada verdadeira, ent\u00e3o dizemos que M satisfaz ou \u00e9 um  modelo para \u03b1.</p> <p>A rela\u00e7\u00e3o l\u00f3gica entre senten\u00e7as \u00e9 expressa pela nota\u00e7\u00e3o \u03b1\u22a8\u03b2. Isso significa  que \u03b1 \u00e9 consequ\u00eancia l\u00f3gica de \u03b2 (\u03b1 implica \u03b2), ou que \u03b2 \u00e9 verdadeiro se, e  somente se, \u03b1 tamb\u00e9m for verdadeiro.</p> <p>Ent\u00e3o tendo uma base de conhecimentos KB, e um algoritmo de infer\u00eancia tiver  a capacidade de derivar \u03b1 de KB, podemos escrever logicamente: \u03b1 \u00e9 derivado  de KB por i ou i deriva \u03b1 de KB.</p> <p>Quando a sintaxe da l\u00f3gica proposicional que \u00e9 utilizada para criar as rela\u00e7\u00f5es entre as senten\u00e7as do nosso agente, podemos definir os seguintes simbolos:</p> <p>Snippet ipsis litteris retirado do slide da aula 12 de Intelig\u00eancia  Artificial, ministrada na Universidade de Bras\u00edlia pelo professor  Fabiano Ara\u00fajo Soares:</p> <pre><code>\u00ac (n\u00e3o, NOT). Uma senten\u00e7a como \u00acW1,3 \u00e9 chamada de nega\u00e7\u00e3o de W1,3. \u200b\n\n\u2227 (e, AND). Uma senten\u00e7a cujo conectivo principal \u00e9 \u2227, como W1,3 \u2227 P3,1, \u00e9 chamada de conjun\u00e7\u00e3o;\u200b\n\n\u2228 (ou, OR). Uma senten\u00e7a cujo conectivo principal \u00e9 \u2228, como W1,3 \u2228 P3,1, \u00e9 uma disjun\u00e7\u00e3o; \u200b\n\n\u21d2 (implica, IMPLIES). Uma senten\u00e7a como (W1,3 \u2227 P3,1) \u21d2 \u00acW2,2 \u00e9 chamada de implica\u00e7\u00e3o (ou condicional). Sua premissa ou antecedente \u00e9 (W1,3 \u2227 P3,1), e sua conclus\u00e3o ou consequente \u00e9 \u00acW2,2. As implica\u00e7\u00f5es tamb\u00e9m s\u00e3o conhecidas como regras ou declara\u00e7\u00f5es if-then. A implica\u00e7\u00e3o \u00e9 escrita em outros livros como \u2283 ou \u2192.\u200b\n\n\u21d4 (se e somente se). A senten\u00e7a W1,3 \u21d4 \u00acW2,2 \u00e9 uma bicondicional.\u200b\n\nTemos tamb\u00e9m o ou exclusivo: N\u00e3o h\u00e1 consenso sobre o s\u00edmbolo para ou exclusivo, a princ\u00edpio, vamos adorar \u2295.\u200b\n</code></pre> <p>Na programa\u00e7\u00e3o podemos utilizar a forma Backus-Naur (BNF) para expressar a sintaxe da l\u00f3gica dos programas.</p>"},{"location":"knowledge_based_agends/#estrutura-basica-bnf","title":"Estrutura B\u00e1sica BNF","text":"<p>S\u00edmbolos Terminais: S\u00e3o os elementos b\u00e1sicos da linguagem  (por exemplo, palavras-chave, operadores, n\u00fameros literais).  Eles s\u00e3o escritos como est\u00e3o, sem necessidade de defini\u00e7\u00e3o adicional.</p> <p>S\u00edmbolos N\u00e3o-Terminais: Representam conjuntos de sequ\u00eancias de s\u00edmbolos  terminais e n\u00e3o-terminais. Eles s\u00e3o usualmente descritos em termos de outros  s\u00edmbolos n\u00e3o-terminais e terminais.</p> <p>Regras de Produ\u00e7\u00e3o: S\u00e3o declara\u00e7\u00f5es que descrevem como os s\u00edmbolos  n\u00e3o-terminais podem ser combinados para formar sequ\u00eancias v\u00e1lidas na linguagem.  Cada regra de produ\u00e7\u00e3o tem um s\u00edmbolo n\u00e3o-terminal no lado esquerdo do sinal  de igual (::=) e os s\u00edmbolos que definem esse n\u00e3o-terminal no lado direito.</p> <p>Exemplo Simples</p> <p>Considere uma linguagem simples onde definimos que uma \"express\u00e3o\" pode ser um  n\u00famero, uma adi\u00e7\u00e3o ou uma subtra\u00e7\u00e3o:</p> <pre><code>&lt;expression&gt; ::= &lt;number&gt;\n               | &lt;expression&gt; \"+\" &lt;expression&gt;\n               | &lt;expression&gt; \"-\" &lt;expression&gt;\n&lt;number&gt; ::= \"0\" | \"1\" | \"2\" | ... | \"9\"\n</code></pre> <p>Esse conceito \u00e9 utilizado n\u00e3o s\u00f3 em intelig\u00eancia artificial, mas tamb\u00e9m em interpretadores de linguagem por exemplo.</p> <p>Em 2019, eu fiz uma linguagem de programa\u00e7\u00e3o interpretada que utiliza a forma Backus-Naur para definir as regras da linguagem. Essa linguagem utiliza uma sintaxe formada por palavras em latim. O projeto \u00e9 chamado de  Latym-language pois foi desenvolvido em Python.</p> <p>Podemos ver no arquvio grammar.lark como que as regras da sintaxe foram definidas.</p> <p>Observe que a sint\u00e1tica apenas define sintaxe, sendo necess\u00e1rio outro formato de defini\u00e7\u00e3o para a sem\u00e2ntica.</p> <p>J\u00e1 quando falamos da sem\u00e2ntica da l\u00f3gica proposicional, a sem\u00e2ntica define as regras para determinar quando uma senten\u00e7a \u00e9 verdadeira em um determinado modelo.</p> <p>Darei mais detalhes sobre l\u00f3gica ao explicar o projeto desenvolvido para a entrega deste compilado sobre agentes baseados em conhecimento.</p>"},{"location":"knowledge_based_agends/#processo-de-inferencia","title":"Processo de infer\u00eancia","text":"<p>No campo da intelig\u00eancia artificial, especialmente relevante para n\u00f3s como  engenheiros de software, o processo de infer\u00eancia \u00e9 um aspecto central que  permeia v\u00e1rias \u00e1reas e aplica\u00e7\u00f5es. Este processo se baseia em deduzir  conclus\u00f5es l\u00f3gicas a partir de informa\u00e7\u00f5es dispon\u00edveis, utilizando tanto  racioc\u00ednio dedutivo quanto indutivo. A dedu\u00e7\u00e3o se concentra em tirar conclus\u00f5es  necess\u00e1rias de premissas consideradas verdadeiras, enquanto a indu\u00e7\u00e3o visa  extrair conclus\u00f5es prov\u00e1veis a partir de observa\u00e7\u00f5es.</p> <p>A l\u00f3gica formal desempenha um papel crucial aqui, fornecendo uma estrutura  rigorosa para representar e inferir conhecimento. Ela ajuda a distinguir entre  infer\u00eancia dedutiva, que lida com conclus\u00f5es necess\u00e1rias a partir de premissas  conhecidas, e infer\u00eancia indutiva, que busca padr\u00f5es para gerar conclus\u00f5es  prov\u00e1veis. Em intelig\u00eancia artificial, isso se traduz em sistemas de infer\u00eancia  autom\u00e1tica, como os sistemas baseados em regras, que aplicam regras l\u00f3gicas  para eficientemente inferir novas informa\u00e7\u00f5es.</p> <p>Al\u00e9m disso, a infer\u00eancia probabil\u00edstica, que lida com incertezas e atribui  probabilidades \u00e0s conclus\u00f5es, \u00e9 vital em contextos onde a certeza absoluta \u00e9  inalcan\u00e7\u00e1vel. Redes Bayesianas s\u00e3o um exemplo t\u00edpico dessa aplica\u00e7\u00e3o. Nos  sistemas baseados em conhecimento, observamos um ciclo de infer\u00eancia que  envolve a coleta de informa\u00e7\u00f5es, consulta \u00e0 base de conhecimento, dedu\u00e7\u00e3o de  a\u00e7\u00f5es apropriadas e, por fim, a execu\u00e7\u00e3o dessas a\u00e7\u00f5es.</p> <p>No aprendizado de m\u00e1quina, a infer\u00eancia \u00e9 fundamental na capacidade do modelo  de generalizar a partir dos dados de treinamento para fazer previs\u00f5es sobre  novos dados. Assim, seja em sistemas baseados em regras ou em aprendizado de  m\u00e1quina, a habilidade de realizar infer\u00eancias l\u00f3gicas e probabil\u00edsticas \u00e9  essencial para desenvolver solu\u00e7\u00f5es eficazes em IA. Este entendimento \u00e9 crucial  para n\u00f3s na engenharia de software, pois permite criar sistemas mais  inteligentes e adapt\u00e1veis.</p>"},{"location":"knowledge_based_agends/#agente-baseado-em-logica-proposicional","title":"Agente baseado em l\u00f3gica proposicional","text":"<p>Definimos um agente baseado em l\u00f3gica proposicional, aquele que consegue, ao utilizar uma base de conhecimento, tomar a\u00e7\u00f5es baseado nas rela\u00e7\u00f5es entre as senten\u00e7as.</p> <p>Podemos relembrar a Backus-Naur Form para expressar problemas para agentes baseados em l\u00f3gica proposicional, de formas que para expressar as senten\u00e7as podemos usar proposi\u00e7\u00f5es simples, que s\u00e3o unidades b\u00e1sicas de conhecimentos, ou tamb\u00e9m podem ser chamadas de \u00e1tomos, visto que s\u00e3o senten\u00e7as indivis\u00edveis. E para relacionar essas proposi\u00e7\u00f5es podemos utilizar Conjun\u00e7\u00f5es e Disjun\u00e7\u00f5es, como os operadores l\u00f3gicos <code>AND</code> (conjun\u00e7\u00e3o \"e\") ou <code>OR</code> (disjun\u00e7\u00e3o \"ou\"), permitindo assim a cria\u00e7\u00e3o de senten\u00e7as complexas.</p> <p>A l\u00f3gica proposicional \u00e9 uma forma simples e formal de representar  conhecimentos, vantajosa pela sua clareza, simplicidade e facilidade de  implementa\u00e7\u00e3o. Contudo, ela \u00e9 limitada em expressividade, n\u00e3o sendo adequada  para representar rela\u00e7\u00f5es complexas ou conhecimento hier\u00e1rquico. Al\u00e9m disso,  enfrenta desafios de escalabilidade em sistemas mais complexos, onde a adi\u00e7\u00e3o  de novos fatos pode levar a um aumento exponencial nas combina\u00e7\u00f5es a serem  consideradas.</p>"},{"location":"knowledge_based_agends/#projeto-e-discussoes","title":"Projeto e discuss\u00f5es","text":""},{"location":"knowledge_based_agends/#prolog","title":"Prolog","text":"<p>Agentes baseados em conhecimento podem ser utilizado em in\u00fameras aplica\u00e7\u00f5es, tanto em jogos quanto em contexto medicinal por exemplo, ajudando em an\u00e1lises e identifica\u00e7\u00e3o de poss\u00edveis problemas.</p> <p>Podemos citar que esse tipo de agente n\u00e3o \u00e9 novidade no ramo da intelig\u00eancia artificial. Uma linguagem que consegue ter a vantagem de facilidade do desenvolvimento desses agentes \u00e9 Prolog, que \u00e9 uma linguagem que utiliza um paradigma l\u00f3gico matem\u00e1tico.</p> <p>Prolog \u00e9 amplamente utilizado em sistemas de infer\u00eancia e resolu\u00e7\u00e3o de  problemas em IA, gra\u00e7as \u00e0 sua habilidade natural de representar regras de  conhecimento e realizar infer\u00eancias l\u00f3gicas. Tamb\u00e9m \u00e9 eficiente em problemas de  busca, processamento de linguagem natural e na representa\u00e7\u00e3o de conhecimento e  ontologias, sendo \u00fatil para prototipagem r\u00e1pida devido \u00e0 sua natureza de alto  n\u00edvel. Apesar de suas vantagens, Prolog tem limita\u00e7\u00f5es em termos de desempenho, principalmente em aplica\u00e7\u00f5es que exigem alto processamento. Sua curva de  aprendizado pode ser \u00edngrime para quem est\u00e1 acostumado com linguagens  imperativas, e a escalabilidade pode ser um desafio em sistemas muito grandes e  complexos.</p> <p>Eu j\u00e1 desenvolvi um sistema em Prolog  para gerar a Classifica\u00e7\u00e3o de Manchester em um hospital fict\u00edcio. O sistema utiliza conhecimento sobre a situa\u00e7\u00e3o dos pacientes para fazer um rankeamento e gerar uma fila de prioridade para o atendimento.</p>"},{"location":"knowledge_based_agends/#coup-simplificado","title":"Coup Simplificado","text":"<p>Para exemplificar e explicar um pouco melhor como um agente baseado em  conhecimento funciona, fiz um programa que simula uma vers\u00e3o simplificada do jogo  Coup.</p> <p>As regras do jogo s\u00e3o:     - Inicialmente cada jogador recebe duas cartas e duas moedas.     - Quando \u00e9 a vez do jogador, ele pode escolher realizar uma a\u00e7\u00e3o comum ou uma a\u00e7\u00e3o da carta.     - Algumas cartas podem bloquear certas a\u00e7\u00f5es.     - Quando um jogador possui 10 ou mais moedas, ele \u00e9 obrigado a realizar a a\u00e7\u00e3o de golpe de estado.     - Ganha o jogador que ainda tiver carta quando nenhum outro jogador tem uma carta.</p> <p>As a\u00e7\u00f5es comuns s\u00e3o:     - Coup, ou Golpe de Estado: O jogador gasta 7 moedas e elimina uma carta inimiga, e essa a\u00e7\u00e3o n\u00e3o pode ser bloqueada.     - Income, ou Renda: O jogador pega apenas uma moeda do jogo para si, esta a\u00e7\u00e3o n\u00e3o pode ser bloqueada.     - Foreign Aid, ou Ajuda Externa: O jogador pode pegar duas moedas do jogo, por\u00e9m um Duque pode bloquear essa a\u00e7\u00e3o.</p> <p>As cartas s\u00e3o chamadas de influ\u00eancias:     - Duque (Duke)         - Tax: O duque pode pegar 3 moedas do jogo para si, esta a\u00e7\u00e3o n\u00e3o pode ser bloqueada.         - O duque pode bloquear a a\u00e7\u00e3o de Ajuda Externa de outro jogador.     - Capit\u00e3o (Captain)         - O capit\u00e3o pode roubar duas moedas de outro jogador, essa a\u00e7\u00e3o pode ser bloqueada se e somente se o outro jogador tamb\u00e9m tiver um capit\u00e3o.     - Assassino (Assassin)         - O assassino gasta 3 moedas para tentar assassinar outro jogador. Essa a\u00e7\u00e3o pode ser bloqueada se e somente se o outro jogador tiver uma Condessa.     - Condessa (Contessa)         - Apenas bloqueia o assassinado de si mesmo.</p> <p>Observa\u00e7\u00e3o: Para fins de simplicidade o Embaixador foi retirado do jogo.</p> <p>Observa\u00e7\u00e3o 2: Para fins de simplicidade retiramos a possibilidade de Blefe.</p> <p>O c\u00f3digo do jogo se encontra na pasta ai_coup dentro do reposit\u00f3rio do presente documento.</p>"},{"location":"knowledge_based_agends/#execucao","title":"Execu\u00e7\u00e3o","text":"<p>Para executar o projeto, basta executar o comando:</p> <pre><code>python main.py\n</code></pre> <p>A partir da\u00ed, o programa ir\u00e1 imprimir na tela que opera\u00e7\u00f5es os jogadores est\u00e3o realizando e como os agentes baseados em conhecimento est\u00e3o tomando deci\u00f5es e guardando conhecimentos em sua base. Exemplo:</p> <pre><code>------------------\nBob has 5 coins and [Assassin, Duke] cards\nShirley has 2 coins and [Contessa, Contessa] cards\n\u001b[32mAI Guilherme\u001b[37m has 2 coins and [Contessa, Captain] cards\n\u001b[32mAI Kung Lao\u001b[37m has 2 coins and [Duke, Captain] cards\n------------------\n\n\u001b[32mAI Guilherme\u001b[37m's turn\n\u001b[32mAI Guilherme\u001b[37m is targeting Bob because it has 5 coins\n\u001b[32mAI Guilherme\u001b[37m decides to Steal against Bob\nSteal was Successful by Bob\n\u001b[02m\n\u001b[32mAI Guilherme\u001b[37m acknowledged: \u001b[32mAI Guilherme\u001b[37m Steal Bob was Successful\n\u001b[32mAI Guilherme\u001b[37m acknowledged: Bob was stolen\n\u001b[32mAI Guilherme\u001b[37m is predicting the game\nSince Bob played Tax,\u001b[32mAI Guilherme\u001b[37m inferred Bob has a Duke\nSince Bob was stolen,\u001b[32mAI Guilherme\u001b[37m inferred Bob doesnt have a Captain\n\u001b[32mAI Guilherme\u001b[37m inferred, as a final guess, that Bob has ['Duke']\nSince Shirley played Foreign Aid,\u001b[32mAI Guilherme\u001b[37m inferred Shirley doesnt have a Duke\n\u001b[32mAI Guilherme\u001b[37m inferred, as a final guess, that Shirley has []\n\u001b[32mAI Guilherme\u001b[37m inferred, as a final guess, that \u001b[32mAI Kung Lao\u001b[37m has []\n\u001b[0m\n\u001b[02m\n\u001b[32mAI Kung Lao\u001b[37m acknowledged: \u001b[32mAI Guilherme\u001b[37m Steal Bob was Successful\n\u001b[32mAI Kung Lao\u001b[37m acknowledged: Bob was stolen\n\u001b[32mAI Kung Lao\u001b[37m is predicting the game\nSince Bob played Tax,\u001b[32mAI Kung Lao\u001b[37m inferred Bob has a Duke\nSince Bob was stolen,\u001b[32mAI Kung Lao\u001b[37m inferred Bob doesnt have a Captain\n\u001b[32mAI Kung Lao\u001b[37m inferred, as a final guess, that Bob has ['Duke']\nSince Shirley played Foreign Aid,\u001b[32mAI Kung Lao\u001b[37m inferred Shirley doesnt have a Duke\n\u001b[32mAI Kung Lao\u001b[37m inferred, as a final guess, that Shirley has []\nSince \u001b[32mAI Guilherme\u001b[37m played Steal,\u001b[32mAI Kung Lao\u001b[37m inferred \u001b[32mAI Guilherme\u001b[37m has a Captain\n\u001b[32mAI Kung Lao\u001b[37m inferred, as a final guess, that \u001b[32mAI Guilherme\u001b[37m has ['Captain']\n\u001b[0m\n\n------------------\nBob has 3 coins and [Assassin, Duke] cards\nShirley has 2 coins and [Contessa, Contessa] cards\n\u001b[32mAI Guilherme\u001b[37m has 2 coins and [Contessa, Captain] cards\n\u001b[32mAI Kung Lao\u001b[37m has 2 coins and [Duke, Captain] cards\n------------------\n</code></pre> <p>Nesta simula\u00e7\u00e3o temos dois tipos de agente:</p> <ul> <li>Bob e Shirley s\u00e3o agentes que possuem uma l\u00f3gica b\u00e1sica de como jogar o jogo e n\u00e3o possuem base de conhecimento, fazendo assim que possam cometer erros ao tomar decis\u00f5es.</li> <li>AI Guilherme e AI Kung Lao s\u00e3o agentes que possuem base de conhecimento e possuem uma l\u00f3gica programada com a abordagem procedural.</li> </ul> <p>Ent\u00e3o a cada jogada os agentes v\u00e3o percebendo o que aconteceu e adicionando em sua base de conhecimento, para posteriormente inferir quais cartas os jogadores t\u00eam e poder tomar decis\u00f5es mais corretas.</p> <p>Podemos ver nos logs que quando AI Guilherme tentou roubar duas moedas do Bob, que o roubo foi feito com sucesso, ent\u00e3o a partir disso, AI Kung Lao pode inferir que AI Guilherme possui pelomenos um Capit\u00e3o e que Bob n\u00e3o possui um  capit\u00e3o.</p> <pre><code>AI Kung Lao acknowledged: AI Guilherme Steal Bob was Successful\nAI Kung Lao acknowledged: Bob was stolen\nAI Kung Lao is predicting the game\nSince Bob played Tax, AI Kung Lao inferred Bob has a Duke\nSince Bob was stolen, AI Kung Lao inferred Bob doesnt have a Captain\nAI Kung Lao inferred, as a final guess, that Bob has ['Duke']\nSince Shirley played Foreign Aid, AI Kung Lao inferred Shirley doesnt have a Duke\nAI Kung Lao inferred, as a final guess, that Shirley has []\nSince AI Guilherme played Steal,AI Kung Lao inferred AI Guilherme has a Captain\nAI Kung Lao inferred, as a final guess, that AI Guilherme has ['Captain']\n</code></pre> <p>AI Kung Lao tamb\u00e9m continuou inferindo a\u00e7\u00f5es em rodadas passadas do jogo.</p> <p>A l\u00f3gica de infer\u00eancia dos agentes \u00e9 a seguinte:</p> <pre><code>def predict_player_cards(self, player):\n        # Initialize a dictionary to hold the inferred cards for the player\n        inferred_cards = {\n            \"Duke\": 0,\n            \"Assassin\": 0,\n            \"Captain\": 0,\n            \"Contessa\": 0,\n        }\n\n        # Logical propositions based on actions\n        for action in self.knowledge[player][\"actions\"]:\n            if action == \"Tax\":\n                print(\n                    f\"Since {player.name} played Tax,\"\n                    f\"{self.name} inferred {player.name} has a Duke\"\n                )\n                inferred_cards[\"Duke\"] = 1\n            elif action == \"Assassinate\":\n                print(\n                    f\"Since {player.name} played Assassinate,\"\n                    f\"{self.name} inferred {player.name} has an Assassin\"\n                )\n                inferred_cards[\"Assassin\"] = 1\n            elif action == \"Steal\":\n                print(\n                    f\"Since {player.name} played Steal,\"\n                    f\"{self.name} inferred {player.name} has a Captain\"\n                )\n                inferred_cards[\"Captain\"] = 1\n            elif action == \"Block Foreign Aid\":\n                print(\n                    f\"Since {player.name} blocked Foreign Aid,\"\n                    f\"{self.name} inferred {player.name} has a Duke\"\n                )\n                inferred_cards[\"Duke\"] = 1\n            elif action == \"Block Assassination\":\n                print(\n                    f\"Since {player.name} blocked Assassination,\"\n                    f\"{self.name} inferred {player.name} has a Contessa\"\n                )\n                inferred_cards[\"Contessa\"] = 1\n            elif action in [\"Foreign Aid\", \"Income\"]:\n                print(\n                    f\"Since {player.name} played {action},\"\n                    f\"{self.name} inferred {player.name} doesnt have a Duke\"\n                )\n                inferred_cards[\"Duke\"] = 0\n            elif action == \"Assassinated\":\n                print(\n                    f\"Since {player.name} was assassinated,\"\n                    f\"{self.name} inferred {player.name} doesnt have a \"\n                    f\"Contessa\"\n                )\n                inferred_cards[\"Contessa\"] = 0\n            elif action == \"Stolen\":\n                print(\n                    f\"Since {player.name} was stolen,\"\n                    f\"{self.name} inferred {player.name} doesnt have a \"\n                    f\"Captain\"\n                )\n                inferred_cards[\"Captain\"] = 0\n            elif action == 'No block Foreign Aid':\n                print(\n                    f\"Since no one blocked Foreign Aid,\"\n                    f\"{self.name} inferred {player.name} doesnt have a \"\n                    f\"Duke\"\n                )\n                inferred_cards[\"Duke\"] = 0\n            elif action == 'Block Stealing':\n                print(\n                    f\"Since {player.name} blocked Stealing,\"\n                    f\"{self.name} inferred {player.name} has a Captain\"\n                )\n                inferred_cards[\"Captain\"] = 1\n\n        cards = filter(lambda x: x[1] &gt; 0, inferred_cards.items())\n\n        # Find the two most likely cards\n        sorted_cards = sorted(cards, key=lambda x: x[1], reverse=True)\n\n        most_likely_cards = [card[0] for card in sorted_cards[:2]]\n\n        print(\n            f\"{self.name} inferred, as a final guess, \"\n            f\"that {player.name} has {most_likely_cards}\"\n        )\n\n        return most_likely_cards\n</code></pre> <p>\u00c9 uma l\u00f3gica simples, por\u00e9m possui uma falha ao lidar com incertezas.  Por exemplo, quando a partida come\u00e7a e ainda n\u00e3o temos nenhum conhecimento sobre os outros jogadores. Por\u00e9m isso \u00e9 f\u00e1cil de resolver, incrementando o agente com l\u00f3gica baseada em probabilidade.</p> <p>Enquanto isso temos a l\u00f3gica para a tomada de decis\u00f5es na jogada. Primeiro o agente ir\u00e1 escolher o jogador mais amea\u00e7ador  (com mais cartas e mais moedas) e em seguida ir\u00e1 definir o que \u00e9 poss\u00edvel fazer contra esse jogador tendo como base o conhecimendo de quais cartas esse jogador possui. Caso n\u00e3o seja poss\u00edvel realizar nenhuma a\u00e7\u00e3o contra esse jogador, o agente ir\u00e1 ver qual outra a\u00e7\u00e3o ele pode fazer sem ser bloqueado por outro jogador.</p> <pre><code>    def get_target_priority(self):\n        def sort_key(target):\n            return (\n                self.knowledge[target][\"card_amount\"], \n                self.knowledge[target][\"coins\"]\n            )\n\n        return sorted(\n            self.players,\n            key=sort_key,\n            reverse=True,\n        )\n\n    def decide_action(self):\n        target_list = self.get_target_priority()\n        for target in target_list:\n            if target.name == self.name:\n                continue\n\n            print(\n                f\"{self.name} is targeting {target.name} because it has \"\n                f\"{target.coins} coins\"\n            )\n\n            if not target.is_alive():\n                print(\"The target is dead... choosing other target\")\n                continue\n\n            if self.coins &gt;= 10:\n                print(\n                    f\"{self.name} has 10+ coins and is obligated to coup\"\n                )\n                return Coup, target\n\n            random.shuffle(self.cards)\n\n            for card in self.cards:\n                if card.has_action:\n                    if (\n                        card.action.name == 'Assassinate' and \n                        (\n                            self.coins &lt; 3 or \n                            self.target_has(target, \"Contessa\")\n                        )\n                    ):\n                        print(\n                            f\"{self.name} knows that can't assassinate \"\n                            f\"{target.name}\"\n                        )\n                        continue\n\n                    if self.coins &gt;= 7:\n                        return Coup, target\n\n                    if (\n                        card.action.name == 'Steal' and \n                        self.target_has(target, \"Captain\")\n                    ):\n                        print(\n                            f\"{self.name} knows that can't steal \"\n                            f\"from {target.name}\"\n                        )\n                        continue\n\n                    target = (target if card.action.require_target else None)\n\n                    return card.action, target\n\n            if self.game_hasnt(\"Duke\"):\n                return ForeignAid, None\n\n            return Income, None\n</code></pre>"},{"location":"knowledge_based_agends/#bibliografia","title":"Bibliografia","text":"<ul> <li> <p>Aula 12 de Intelig\u00eancia Artificial, ministrada na Universidade de Bras\u00edlia pelo professor Fabiano Ara\u00fajo Soares.</p> </li> <li> <p>https://www.inf.ufsc.br/~alexandre.goncalves.silva/courses/14s2/ine5633/slides/aula1021.pdf</p> </li> <li> <p>https://www.ime.usp.br/~leliane/IAcurso2006/slides/Aula7-LProposicional-I-2006.pdf</p> </li> <li> <p>https://www.cin.ufpe.br/~in1116/aulas/agentes-bc.pptx</p> </li> <li> <p>https://www.swi-prolog.org/pldoc/doc_for?object=manual</p> </li> </ul>"},{"location":"portfolio_2_discussions/","title":"Discuss\u00f5es sobre resolu\u00e7\u00e3o de problemas por busca","text":""},{"location":"portfolio_2_discussions/#sugestoes-de-aprimoramento","title":"Sugest\u00f5es de Aprimoramento","text":"<ol> <li> <p>Algoritmos H\u00edbridos: Combinar diferentes tipos de algoritmos de busca pode fornecer um meio termo entre efic\u00e1cia e efici\u00eancia. Por exemplo, usar algoritmos gen\u00e9ticos para explorar o espa\u00e7o de busca e em seguida refinar os resultados com Busca Local.</p> </li> <li> <p>Aprendizado de M\u00e1quina para Heur\u00edsticas: Utilizar t\u00e9cnicas de aprendizado de m\u00e1quina para gerar heur\u00edsticas adaptativas pode melhorar o desempenho dos algoritmos de busca informada.</p> </li> <li> <p>Modelos Probabil\u00edsticos: Incorporar modelos probabil\u00edsticos para lidar com incerteza pode tornar os algoritmos mais robustos em ambientes din\u00e2micos e incertos.</p> </li> <li> <p>Paralelismo e Distribui\u00e7\u00e3o: T\u00e9cnicas de computa\u00e7\u00e3o paralela podem ser aplicadas para melhorar a efici\u00eancia computacional, tornando os algoritmos mais pr\u00e1ticos para aplica\u00e7\u00f5es em tempo real.</p> </li> <li> <p>Otimiza\u00e7\u00e3o Multiobjetivo: Adaptar algoritmos para considerar m\u00faltiplos objetivos pode torn\u00e1-los mais vers\u00e1teis e aplic\u00e1veis a uma gama mais ampla de problemas.</p> </li> </ol> <p>Enquanto os algoritmos de busca continuam sendo uma parte vital da caixa de  ferramentas de IA, h\u00e1 espa\u00e7o substancial para melhorias. Abordagens  interdisciplinares que combinam teoria da otimiza\u00e7\u00e3o, aprendizado de m\u00e1quina e  m\u00e9todos estat\u00edsticos s\u00e3o particularmente promissoras para abordar as limita\u00e7\u00f5es  existentes e levar a efic\u00e1cia desses algoritmos a novos patamares.</p>"},{"location":"portfolio_2_discussions/#heuristica-adicional","title":"Heur\u00edstica adicional","text":"<p>Uma t\u00e9cnica muito utilizada em IA que talvez esteja relacionado com este  assunto seja o c\u00e1lculo do gradiente descendente. O Gradiente Descendente \u00e9 uma t\u00e9cnica de otimiza\u00e7\u00e3o usada para encontrar o  m\u00ednimo local de uma fun\u00e7\u00e3o. Embora n\u00e3o seja um algoritmo de busca no sentido  tradicional, ele tem algumas semelhan\u00e7as e diferen\u00e7as importantes em rela\u00e7\u00e3o  aos algoritmos de busca, especialmente no contexto da Intelig\u00eancia Artificial.</p>"},{"location":"portfolio_2_discussions/#relacao-com-algoritmos-de-busca","title":"Rela\u00e7\u00e3o com Algoritmos de Busca","text":"<ol> <li> <p>Objetivo de Otimiza\u00e7\u00e3o: Tanto os algoritmos de busca quanto o Gradiente  Descendente visam encontrar solu\u00e7\u00f5es \u00f3timas ou aproximadas para um determinado  problema. No caso dos algoritmos de busca, o objetivo \u00e9 frequentemente  encontrar o caminho mais curto ou de menor custo, enquanto o Gradiente  Descendente busca minimizar uma fun\u00e7\u00e3o de custo.</p> </li> <li> <p>Espa\u00e7o de Solu\u00e7\u00f5es: Ambos operam em um espa\u00e7o de solu\u00e7\u00f5es definido, mas  enquanto os algoritmos de busca geralmente trabalham em espa\u00e7os discretos  (como um grafo ou uma \u00e1rvore), o Gradiente Descendente opera em espa\u00e7os  cont\u00ednuos.</p> </li> <li> <p>Informa\u00e7\u00e3o Local vs. Global: O Gradiente Descendente utiliza informa\u00e7\u00f5es  locais sobre a inclina\u00e7\u00e3o da fun\u00e7\u00e3o de custo para se mover em dire\u00e7\u00e3o ao  m\u00ednimo. Isso \u00e9 semelhante a algoritmos de busca local como o Hill Climbing,  que tamb\u00e9m fazem movimentos locais para encontrar uma solu\u00e7\u00e3o \u00f3tima.</p> </li> <li> <p>Heur\u00edsticas: Em algoritmos de busca informada, as heur\u00edsticas s\u00e3o usadas  para guiar a busca. No Gradiente Descendente, o pr\u00f3prio gradiente atua como   uma esp\u00e9cie de \"heur\u00edstica\", direcionando o algoritmo para onde a fun\u00e7\u00e3o   decresce mais rapidamente.</p> </li> </ol>"},{"location":"portfolio_2_discussions/#bibliografia","title":"Bibliografia","text":"<p>https://pt.d2l.ai/chapter_optimization/sgd.html</p> <p>http://cursos.leg.ufpr.br/ML4all/apoio/Gradiente.html</p> <p>https://didatica.tech/gradiente-descendente-estocastico/</p>"},{"location":"portfolio_2_projects/","title":"Projetos e problemas","text":"<p>Algoritmos de busca possuem muitas aplicabilidades e s\u00e3o muito parecidos; Inclusive, um motivo para isso \u00e9 que muitos algoritmos de busca s\u00e3o varia\u00e7\u00f5es de um mesmo algoritmo. Por\u00e9m, cada um possui suas vantagens e desvantagens, e \u00e9 importante saber quando utilizar cada um deles.</p>"},{"location":"portfolio_2_projects/#lootmaze","title":"LootMaze","text":"<p>O LootMaze \u00e9 um jogo que criei para experimentar com diferentes tipos de algoritmos de busca. O jogo \u00e9 um labirinto onde o jogador deve encontrar o caminho mais curto para chegar ao objetivo. O c\u00f3digo est\u00e1 dispon\u00edvel no Github.</p> <p>Este projeto inclui uma interface gr\u00e1fica para visualizar o labirinto e os algoritmos de busca em a\u00e7\u00e3o. Em cada execu\u00e7\u00e3o do jogo, o personagem no jogo executa os algoritmos A* (A-star), Dijkstra e DFS (Depth-First Search) para encontrar o caminho mais curto para o objetivo.</p> <p>A cada execu\u00e7\u00e3o do algoritmo, \u00e9 registrado a visualiza\u00e7\u00e3o dos passos que o algoritmo tomou para encontrar o caminho mais curto. Tamb\u00e9m \u00e9 exibido a quantidade de passos que o algoritmo tomou para encontrar o caminho mais curto e tamb\u00e9m o tamanho do mesmo.</p> <p>Assim que o algoritmo encontra o caminho mais curto, o personagem executa uma anima\u00e7\u00e3o seguindo o caminho encontrado.</p> <p></p> <p>Um ponto interessante do jogo \u00e9 que os labirintos s\u00e3o personaliz\u00e1veis. O arquivo que guarda as informa\u00e7\u00f5es do labirinto \u00e9 na verdade um arquivo PNG, ent\u00e3o fica f\u00e1cil de editar e criar novos labirintos para experimentar com os algoritmos.</p> <p>Esse jogo \u00e9 um \u00f3timo projeto para adicionar melhorias como obstaculos e inimigos tanto como novos algoritmos e heur\u00edsticas para encontrar o objetivo.</p> <p>No caso, para o algoritmo A* no jogo, implementei usando a Manhattan Distance para estimar o custo do caminho mais curto.</p>"},{"location":"problem_solving_agents/","title":"Agentes solucionadores de problemas","text":""},{"location":"problem_solving_agents/#definicao-de-problema","title":"Defini\u00e7\u00e3o de problema","text":"<p>Podemos definir um problema usando quatro caracter\u00edsticas:</p> <ul> <li>Estado inicial do problema</li> <li>A\u00e7\u00f5es poss\u00edveis</li> <li>Teste de t\u00e9rmino</li> <li>Fun\u00e7\u00e3o de custo da solu\u00e7\u00e3o</li> </ul>"},{"location":"problem_solving_agents/#estado-inicial-do-problema","title":"Estado inicial do problema","text":"<p>Onde o agente \u00e9 iniciado.  Ex: posi\u00e7\u00e3o inicial de um rob\u00f4.</p>"},{"location":"problem_solving_agents/#acoes-possiveis","title":"A\u00e7\u00f5es poss\u00edveis","text":"<p>Conjunto de a\u00e7\u00f5es que o agente pode executar, pela fun\u00e7\u00e3o sucessor ou pelo conjunto de operadores.  Sendo que a fun\u00e7\u00e3o sucessor \u00e9 uma fun\u00e7\u00e3o que recebe um estado e retorna um conjunto de a\u00e7\u00f5es poss\u00edveis. E o conjunto de operadores \u00e9 um conjunto de a\u00e7\u00f5es poss\u00edveis para gerar os sucessores. Ex: movimentar-se para frente, para tr\u00e1s, para esquerda ou para direita.</p>"},{"location":"problem_solving_agents/#um-teste-de-termino","title":"Um teste de t\u00e9rmino","text":"<p>Define um conjunto de estados que s\u00e3o considerados como solu\u00e7\u00e3o, sendo que estes estados podem ser chamados de objetivo. Por\u00e9m esse conjunto de estados pode ser algo mais simples e abstrato, assim como uma situa\u00e7\u00e3o de check-mate no xadrez.</p>"},{"location":"problem_solving_agents/#funcao-de-custo-da-solucao","title":"Fun\u00e7\u00e3o de custo da solu\u00e7\u00e3o","text":"<p>\u00c9 uma fun\u00e7\u00e3o que recebe uma solu\u00e7\u00e3o e retorna um valor num\u00e9rico que representa o custo da solu\u00e7\u00e3o, tamb\u00e9m conhecida por medida de desempenho.  O objetivo \u00e9 encontrar a solu\u00e7\u00e3o com o menor custo poss\u00edvel.</p>"},{"location":"problem_solving_agents/#problemas-de-malha-fechada-e-malha-aberta-em-agentes-de-solucoes-de-problemas","title":"Problemas de Malha Fechada e Malha Aberta em Agentes de Solu\u00e7\u00f5es de Problemas","text":"<p>Os termos \"malha fechada\" e \"malha aberta\" s\u00e3o frequentemente usados para  descrever o grau de intera\u00e7\u00e3o e feedback entre um agente e seu ambiente.  Ambos t\u00eam implica\u00e7\u00f5es importantes no design e na opera\u00e7\u00e3o de agentes de  solu\u00e7\u00f5es de problemas.</p>"},{"location":"problem_solving_agents/#malha-fechada","title":"Malha Fechada","text":"<p>Em um sistema de malha fechada, o agente recebe feedback cont\u00ednuo do ambiente  e ajusta suas a\u00e7\u00f5es com base nesse feedback. Isso \u00e9 comum em cen\u00e1rios onde o  estado do ambiente pode mudar dinamicamente, e o agente precisa se adaptar a  essas mudan\u00e7as em tempo real.</p>"},{"location":"problem_solving_agents/#como-funciona","title":"Como Funciona:","text":"<p>O agente toma uma a\u00e7\u00e3o, observa o resultado e o usa para informar a pr\u00f3xima  a\u00e7\u00e3o.</p>"},{"location":"problem_solving_agents/#aplicacoes","title":"Aplica\u00e7\u00f5es:","text":"<p>Rob\u00f3tica, onde o rob\u00f4 precisa se ajustar a obst\u00e1culos em movimento. Mercados financeiros, onde o agente de negocia\u00e7\u00e3o precisa se adaptar \u00e0s  flutua\u00e7\u00f5es de pre\u00e7o.</p>"},{"location":"problem_solving_agents/#desafios","title":"Desafios:","text":"<p>Requer capacidade de processamento em tempo real. Pode exigir algoritmos de aprendizado por refor\u00e7o ou outros m\u00e9todos de  aprendizado de m\u00e1quina para adaptar-se eficazmente.</p>"},{"location":"problem_solving_agents/#malha-aberta","title":"Malha Aberta","text":"<p>Em um sistema de malha aberta, o agente n\u00e3o recebe feedback em tempo real ou  n\u00e3o o utiliza para ajustar suas a\u00e7\u00f5es futuras. Ele se baseia mais em um modelo  predefinido do ambiente e em um plano estabelecido.</p>"},{"location":"problem_solving_agents/#como-funciona_1","title":"Como Funciona:","text":"<p>O agente toma uma s\u00e9rie de a\u00e7\u00f5es com base em um plano predefinido, sem  necessariamente revisar ou ajustar o plano em resposta \u00e0s mudan\u00e7as no ambiente.</p>"},{"location":"problem_solving_agents/#aplicacoes_1","title":"Aplica\u00e7\u00f5es:","text":"<p>Resolu\u00e7\u00e3o de problemas de quebra-cabe\u00e7a como o Cubo de Rubik. Planejamento de rota em um mapa est\u00e1tico.</p>"},{"location":"problem_solving_agents/#desafios_1","title":"Desafios:","text":"<p>Menos adapt\u00e1vel a mudan\u00e7as no ambiente. O plano inicial precisa ser bem elaborado para garantir o sucesso.</p>"},{"location":"problem_solving_agents/#interseccao-entre-malha-fechada-e-malha-aberta","title":"Intersec\u00e7\u00e3o entre Malha Fechada e Malha Aberta","text":"<p>Em muitas aplica\u00e7\u00f5es pr\u00e1ticas, os agentes operam em um espectro entre malha  fechada e malha aberta. Por exemplo, um carro aut\u00f4nomo pode ter um plano de  rota geral (abordagem de malha aberta), mas ainda precisa se adaptar a outros  ve\u00edculos e condi\u00e7\u00f5es da estrada em tempo real (abordagem de malha fechada).</p> <p>Problemas de malha fechada s\u00e3o n\u00e3o deterministicos por sofrer interfer\u00eancias externas do ambiente. J\u00e1 problemas de malha aberta s\u00e3o determin\u00edsticos pois n\u00e3o sofrem interfer\u00eancias externas do ambiente.</p>"},{"location":"problem_solving_agents/#em-resumo","title":"Em Resumo","text":"<p>A escolha entre malha fechada e malha aberta depender\u00e1 do problema espec\u00edfico  que o agente de solu\u00e7\u00f5es de problemas est\u00e1 tentando resolver, do ambiente em  que est\u00e1 operando e dos recursos computacionais dispon\u00edveis. Ambos t\u00eam seus  pr\u00f3prios conjuntos de desafios e vantagens, e compreend\u00ea-los \u00e9 crucial para  o design eficaz de agentes inteligentes.</p>"},{"location":"problem_solving_agents/#bibliografia","title":"Bibliografia","text":"<p>https://edisciplinas.usp.br/pluginfile.php/4848799/mod_resource/content/3/2019-ProblemasComoBusca-BuscaCega.pdf</p> <p>https://edisciplinas.usp.br/pluginfile.php/4183182/mod_resource/content/1/Aula1V2017.pdf</p>"},{"location":"problem_types/","title":"Problemas de Malha Fechada e Malha Aberta em Agentes de Solu\u00e7\u00f5es de Problemas","text":"<p>Os termos \"malha fechada\" e \"malha aberta\" s\u00e3o frequentemente usados para  descrever o grau de intera\u00e7\u00e3o e feedback entre um agente e seu ambiente.  Ambos t\u00eam implica\u00e7\u00f5es importantes no design e na opera\u00e7\u00e3o de agentes de  solu\u00e7\u00f5es de problemas.</p>"},{"location":"problem_types/#malha-fechada","title":"Malha Fechada","text":"<p>Em um sistema de malha fechada, o agente recebe feedback cont\u00ednuo do ambiente  e ajusta suas a\u00e7\u00f5es com base nesse feedback. Isso \u00e9 comum em cen\u00e1rios onde o  estado do ambiente pode mudar dinamicamente, e o agente precisa se adaptar a  essas mudan\u00e7as em tempo real.</p>"},{"location":"problem_types/#como-funciona","title":"Como Funciona:","text":"<p>O agente toma uma a\u00e7\u00e3o, observa o resultado e o usa para informar a pr\u00f3xima  a\u00e7\u00e3o.</p>"},{"location":"problem_types/#aplicacoes","title":"Aplica\u00e7\u00f5es:","text":"<p>Rob\u00f3tica, onde o rob\u00f4 precisa se ajustar a obst\u00e1culos em movimento. Mercados financeiros, onde o agente de negocia\u00e7\u00e3o precisa se adaptar \u00e0s  flutua\u00e7\u00f5es de pre\u00e7o.</p>"},{"location":"problem_types/#desafios","title":"Desafios:","text":"<p>Requer capacidade de processamento em tempo real. Pode exigir algoritmos de aprendizado por refor\u00e7o ou outros m\u00e9todos de  aprendizado de m\u00e1quina para adaptar-se eficazmente.</p>"},{"location":"problem_types/#malha-aberta","title":"Malha Aberta","text":"<p>Em um sistema de malha aberta, o agente n\u00e3o recebe feedback em tempo real ou  n\u00e3o o utiliza para ajustar suas a\u00e7\u00f5es futuras. Ele se baseia mais em um modelo  predefinido do ambiente e em um plano estabelecido.</p>"},{"location":"problem_types/#como-funciona_1","title":"Como Funciona:","text":"<p>O agente toma uma s\u00e9rie de a\u00e7\u00f5es com base em um plano predefinido, sem  necessariamente revisar ou ajustar o plano em resposta \u00e0s mudan\u00e7as no ambiente.</p>"},{"location":"problem_types/#aplicacoes_1","title":"Aplica\u00e7\u00f5es:","text":"<p>Resolu\u00e7\u00e3o de problemas de quebra-cabe\u00e7a como o Cubo de Rubik. Planejamento de rota em um mapa est\u00e1tico.</p>"},{"location":"problem_types/#desafios_1","title":"Desafios:","text":"<p>Menos adapt\u00e1vel a mudan\u00e7as no ambiente. O plano inicial precisa ser bem elaborado para garantir o sucesso.</p>"},{"location":"problem_types/#interseccao-entre-malha-fechada-e-malha-aberta","title":"Intersec\u00e7\u00e3o entre Malha Fechada e Malha Aberta","text":"<p>Em muitas aplica\u00e7\u00f5es pr\u00e1ticas, os agentes operam em um espectro entre malha  fechada e malha aberta. Por exemplo, um carro aut\u00f4nomo pode ter um plano de  rota geral (abordagem de malha aberta), mas ainda precisa se adaptar a outros  ve\u00edculos e condi\u00e7\u00f5es da estrada em tempo real (abordagem de malha fechada).</p> <p>Problemas de malha fechada s\u00e3o n\u00e3o deterministicos por sofrer interfer\u00eancias externas do ambiente. J\u00e1 problemas de malha aberta s\u00e3o determin\u00edsticos pois n\u00e3o sofrem interfer\u00eancias externas do ambiente.</p>"},{"location":"problem_types/#em-resumo","title":"Em Resumo","text":"<p>A escolha entre malha fechada e malha aberta depender\u00e1 do problema espec\u00edfico  que o agente de solu\u00e7\u00f5es de problemas est\u00e1 tentando resolver, do ambiente em  que est\u00e1 operando e dos recursos computacionais dispon\u00edveis. Ambos t\u00eam seus  pr\u00f3prios conjuntos de desafios e vantagens, e compreend\u00ea-los \u00e9 crucial para  o design eficaz de agentes inteligentes.</p>"},{"location":"problem_types/#bibliografia","title":"Bibliografia","text":"<p>https://edisciplinas.usp.br/pluginfile.php/4848799/mod_resource/content/3/2019-ProblemasComoBusca-BuscaCega.pdf</p> <p>https://edisciplinas.usp.br/pluginfile.php/4183182/mod_resource/content/1/Aula1V2017.pdf</p>"},{"location":"search_algorithms/","title":"Algoritmos de Busca","text":"<p>Algoritmos de busca s\u00e3o essenciais para explorar um espa\u00e7o de estados a fim de  encontrar uma solu\u00e7\u00e3o para um determinado problema. Eles s\u00e3o classificados  principalmente em dois tipos: Busca Cega (ou Busca N\u00e3o-Informada) e Busca  Informada.</p>"},{"location":"search_algorithms/#busca-cega-busca-nao-informada","title":"Busca Cega (Busca N\u00e3o-Informada)","text":"<p>Esses algoritmos n\u00e3o t\u00eam informa\u00e7\u00f5es adicionais sobre estados al\u00e9m daqueles  que est\u00e3o expl\u00edcitos no problema. Eles s\u00e3o chamados de \"cegos\" porque exploram  o espa\u00e7o de estados sem qualquer dire\u00e7\u00e3o guiada para encontrar a solu\u00e7\u00e3o.</p>"},{"location":"search_algorithms/#algoritmos-comuns","title":"Algoritmos Comuns:","text":"<ul> <li>Busca em Largura (Breadth-First Search, BFS)</li> <li>Busca em Profundidade (Depth-First Search, DFS)</li> <li>Busca de Custo Uniforme</li> </ul>"},{"location":"search_algorithms/#como-funciona","title":"Como Funciona:","text":"<p>Come\u00e7am a partir de um estado inicial e expandem a fronteira de estados  poss\u00edveis at\u00e9 atingir o estado objetivo.</p>"},{"location":"search_algorithms/#comparacao-entre-breadth-first-search-depth-first-search-e-busca-de-custo-uniforme","title":"Compara\u00e7\u00e3o entre Breadth-First Search, Depth-First Search e Busca de Custo Uniforme","text":"<p>Esses tr\u00eas algoritmos s\u00e3o comumente usados para a resolu\u00e7\u00e3o de problemas e t\u00eam  suas pr\u00f3prias vantagens e desvantagens. Abaixo, segue uma compara\u00e7\u00e3o detalhada  entre Breadth-First Search (BFS), Depth-First Search (DFS) e Busca de Custo  Uniforme (UCS).</p>"},{"location":"search_algorithms/#breadth-first-search-bfs","title":"Breadth-First Search (BFS)","text":""},{"location":"search_algorithms/#exemplo-de-algoritmo-em-python","title":"Exemplo de algoritmo em Python","text":"<pre><code>from collections import deque\n\ndef bfs(graph, start, goal):\n    visited = set()\n    queue = deque([(start, [start])])\n\n    while queue:\n        (current_node, path) = queue.popleft()\n\n        if current_node not in visited:\n            visited.add(current_node)\n\n            if current_node == goal:\n                return path\n\n            for neighbor in graph[current_node]:\n                queue.append((neighbor, path + [neighbor]))\n\n# Exemplo de uso\ngraph = {'A': ['B', 'C'], 'B': ['A', 'D'], 'C': ['A', 'E'], 'D': ['B'], 'E': ['C', 'F'], 'F': ['E']}\nprint(bfs(graph, 'A', 'F'))  # Output: ['A', 'C', 'E', 'F']\n</code></pre> <p>Mecanismo: Explora todos os vizinhos de um n\u00f3 antes de passar para os  vizinhos do pr\u00f3ximo n\u00edvel.</p> <p>Filosofia: \"Expandir primeiro na largura\".</p> <p>Completo: Sim, garante encontrar a solu\u00e7\u00e3o se uma existir.</p> <p>\u00d3timo: Sim, se o custo para cada passo for o mesmo.</p> <p>Uso de Mem\u00f3ria: Elevado, pois mant\u00e9m todos os n\u00f3s em mem\u00f3ria.</p> <p>Aplica\u00e7\u00f5es: \u00datil para encontrar o menor caminho em um espa\u00e7o de estados,  em problemas onde a solu\u00e7\u00e3o mais curta \u00e9 desejada.</p>"},{"location":"search_algorithms/#depth-first-search-dfs","title":"Depth-First Search (DFS)","text":""},{"location":"search_algorithms/#exemplo-de-algoritmo-em-python_1","title":"Exemplo de algoritmo em Python","text":"<pre><code>def dfs(graph, current_node, goal, visited=None, path=None):\n    if visited is None:\n        visited = set()\n    if path is None:\n        path = []\n\n    visited.add(current_node)\n    path.append(current_node)\n\n    if current_node == goal:\n        return path\n\n    for neighbor in graph[current_node]:\n        if neighbor not in visited:\n            new_path = dfs(graph, neighbor, goal, visited, path.copy())\n\n            if new_path:\n                return new_path\n\n# Exemplo de uso\ngraph = {'A': ['B', 'C'], 'B': ['A', 'D'], 'C': ['A', 'E'], 'D': ['B'], 'E': ['C', 'F'], 'F': ['E']}\nprint(dfs(graph, 'A', 'F'))  # Output: ['A', 'B', 'D', 'C', 'E', 'F']\n</code></pre> <p>Mecanismo: Explora t\u00e3o profundamente quanto poss\u00edvel ao longo de cada ramo  antes de retroceder.</p> <p>Filosofia: \"Expandir primeiro em profundidade\".</p> <p>Completo: N\u00e3o necessariamente, especialmente em \u00e1rvores infinitas.</p> <p>\u00d3timo: N\u00e3o, pode encontrar uma solu\u00e7\u00e3o sub\u00f3tima.</p> <p>Uso de Mem\u00f3ria: Menor comparado ao BFS, pois armazena apenas o caminho da raiz at\u00e9 o n\u00f3 atual.</p> <p>Aplica\u00e7\u00f5es: \u00datil em cen\u00e1rios como labirintos e jogos de estrat\u00e9gia, onde  encontrar qualquer solu\u00e7\u00e3o v\u00e1lida \u00e9 mais importante do que encontrar a solu\u00e7\u00e3o  mais curta.</p>"},{"location":"search_algorithms/#busca-de-custo-uniforme-ucs","title":"Busca de Custo Uniforme (UCS)","text":""},{"location":"search_algorithms/#exemplo-de-algoritmo-em-python_2","title":"Exemplo de algoritmo em Python","text":"<pre><code>import heapq\n\ndef ucs(graph, start, goal):\n    visited = set()\n    queue = [(0, start, [])]\n\n    while queue:\n        (cost, current_node, path) = heapq.heappop(queue)\n\n        if current_node not in visited:\n            visited.add(current_node)\n            path = path + [current_node]\n\n            if current_node == goal:\n                return cost, path\n\n            for neighbor, edge_cost in graph[current_node].items():\n                heapq.heappush(queue, (cost + edge_cost, neighbor, path))\n\n# Exemplo de uso\ngraph = {'A': {'B': 1, 'C': 4}, 'B': {'A': 1, 'D': 2}, 'C': {'A': 4, 'E': 3}, 'D': {'B': 2}, 'E': {'C': 3, 'F': 5}, 'F': {'E': 5}}\nprint(ucs(graph, 'A', 'F'))  # Output: (9, ['A', 'B', 'D', 'C', 'E', 'F'])\n</code></pre> <p>Mecanismo: Expandir o n\u00f3 com o menor custo acumulado at\u00e9 agora.</p> <p>Filosofia: \"Expandir com base no custo mais baixo\".</p> <p>Completo: Sim, desde que o custo de cada aresta seja maior que algum valor \u03b5&gt;0.</p> <p>\u00d3timo: Sim, sempre encontra a solu\u00e7\u00e3o de menor custo.</p> <p>Uso de Mem\u00f3ria: Pode ser alto, pois mant\u00e9m todos os n\u00f3s visitados em mem\u00f3ria.</p> <p>Aplica\u00e7\u00f5es: \u00datil em problemas de roteamento, como encontrar o caminho mais curto em um mapa com diferentes custos de deslocamento.</p>"},{"location":"search_algorithms/#resumo-das-diferencas","title":"Resumo das Diferen\u00e7as","text":""},{"location":"search_algorithms/#objetivo","title":"Objetivo:","text":"<ul> <li>BFS \u00e9 geralmente usado para encontrar o caminho mais curto em termos de n\u00famero de passos.</li> <li>DFS \u00e9 usado para encontrar qualquer solu\u00e7\u00e3o v\u00e1lida de forma eficiente em mem\u00f3ria.</li> <li>UCS \u00e9 usado para encontrar o caminho de menor custo.</li> </ul>"},{"location":"search_algorithms/#eficiencia","title":"Efici\u00eancia:","text":"<ul> <li>BFS e UCS s\u00e3o geralmente mais lentos mas produzem melhores solu\u00e7\u00f5es.</li> <li>DFS \u00e9 mais r\u00e1pido e usa menos mem\u00f3ria, mas pode encontrar solu\u00e7\u00f5es sub\u00f3timas.</li> </ul>"},{"location":"search_algorithms/#complexidade-de-espaco","title":"Complexidade de Espa\u00e7o:","text":"<ul> <li>BFS e UCS podem exigir mais mem\u00f3ria.</li> <li>DFS \u00e9 mais eficiente em termos de mem\u00f3ria.</li> </ul>"},{"location":"search_algorithms/#garantia-de-solucao-otima","title":"Garantia de Solu\u00e7\u00e3o \u00d3tima:","text":"<ul> <li>BFS s\u00f3 \u00e9 \u00f3timo quando todos os passos t\u00eam o mesmo custo.</li> <li>DFS n\u00e3o garante uma solu\u00e7\u00e3o \u00f3tima.</li> <li>UCS sempre encontra uma solu\u00e7\u00e3o \u00f3tima, dado que todos os custos de aresta sejam positivos.</li> </ul>"},{"location":"search_algorithms/#busca-informada","title":"Busca Informada","text":"<p>Esses algoritmos usam informa\u00e7\u00f5es adicionais  (geralmente na forma de uma fun\u00e7\u00e3o heur\u00edstica) para fazer escolhas mais  informadas durante a busca, possibilitando encontrar solu\u00e7\u00f5es de forma mais  eficiente.</p>"},{"location":"search_algorithms/#algoritmos-comuns_1","title":"Algoritmos Comuns:","text":"<ul> <li>A* (A-Star)</li> <li>Best-First Search</li> <li>Hill Climbing</li> </ul>"},{"location":"search_algorithms/#como-funciona_1","title":"Como Funciona:","text":"<p>Utilizam uma fun\u00e7\u00e3o heur\u00edstica para estimar o custo do estado atual at\u00e9 o  estado objetivo, priorizando estados que parecem levar a uma solu\u00e7\u00e3o mais  eficiente.</p>"},{"location":"search_algorithms/#comparacao-entre-a-best-first-search-e-hill-climbing","title":"Compara\u00e7\u00e3o entre A*, Best-First Search e Hill Climbing","text":"<p>Esses tr\u00eas algoritmos s\u00e3o tipos de buscas informadas que usam heur\u00edsticas para  direcionar a explora\u00e7\u00e3o. Aqui est\u00e3o suas principais caracter\u00edsticas, vantagens  e desvantagens:</p>"},{"location":"search_algorithms/#a-a-star","title":"A* (A-Star)","text":"<pre><code>\"\"\"\nEste exemplo contempla o uso da dist\u00e2ncia de Manhattan como heur\u00edstica.\n\"\"\"\nimport heapq\n\ndef manhattan_distance(a, b):\n    return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\ndef a_star(graph, start, goal):\n    open_set = [(0, start, [])]  # (f_score, current_node, path)\n    visited = set()\n\n    while open_set:\n        f, current, path = heapq.heappop(open_set)\n\n        if current in visited:\n            continue\n\n        path = path + [current]\n        visited.add(current)\n\n        if current == goal:\n            return f, path\n\n        for neighbor, cost in graph[current].items():\n            g = f - manhattan_distance(current, goal)  # Recalculate g_score\n            h = manhattan_distance(neighbor, goal)\n            f_new = g + cost + h\n\n            heapq.heappush(open_set, (f_new, neighbor, path))\n\n# Exemplo de uso\ngraph = { (0, 0): {(0, 1): 1, (1, 0): 1.5},\n          (0, 1): {(0, 0): 1, (0, 2): 1},\n          (0, 2): {(0, 1): 1, (1, 2): 1},\n          (1, 0): {(0, 0): 1.5, (1, 1): 1},\n          (1, 1): {(1, 0): 1, (1, 2): 1},\n          (1, 2): {(1, 1): 1, (0, 2): 1} }\nstart = (0, 0)\ngoal = (1, 2)\nprint(a_star(graph, start, goal))  # Output: (3.5, [(0, 0), (1, 0), (1, 1), (1, 2)])\n</code></pre> <p>Mecanismo: Utiliza tanto o custo acumulado do n\u00f3 inicial at\u00e9 o n\u00f3 atual (g(n)) como uma fun\u00e7\u00e3o heur\u00edstica estimada do n\u00f3 atual ao n\u00f3 objetivo (h(n)) para priorizar a explora\u00e7\u00e3o.</p> <p>No exemplo acima foi usada a Dist\u00e2ncia de Manhattan como heur\u00edstica, por\u00e9m essa heur\u00edstica \u00e9 apenas um exemplo. O algoritmo pode usar outra fun\u00e7\u00e3o de heur\u00edstica ou combina\u00e7\u00e3o de fun\u00e7\u00f5es de heur\u00edsticas.</p> <p>Filosofia: \"Expandir o n\u00f3 que tem a menor soma de custos g(n) + h(n).\"</p> <p>Completo: Sim, desde que a heur\u00edstica seja admiss\u00edvel e consistente.</p> <p>\u00d3timo: Sim, sob as mesmas condi\u00e7\u00f5es.</p> <p>Aplica\u00e7\u00f5es: Pathfinding, planejamento de movimento, etc.</p> <p>A \u00e9 um algoritmo que tamb\u00e9m possui varia\u00e7\u00f5es, como o A Epsilon, que \u00e9 uma varia\u00e7\u00e3o do A* que permite que o algoritmo explore mais n\u00f3s, por\u00e9m com um custo maior. Isso \u00e9 \u00fatil para encontrar solu\u00e7\u00f5es mais rapidamente, por\u00e9m sub\u00f3timas. Refer\u00eancia sobre varia\u00e7\u00f5es do A*</p>"},{"location":"search_algorithms/#best-first-search","title":"Best-First Search","text":"<pre><code>import heapq\n\ndef best_first_search(graph, start, goal, heuristic):\n    open_set = [(heuristic(start, goal), start, [])]\n    visited = set()\n\n    while open_set:\n        _, current, path = heapq.heappop(open_set)\n\n        if current in visited:\n            continue\n\n        path = path + [current]\n        visited.add(current)\n\n        if current == goal:\n            return path\n\n        for neighbor in graph[current]:\n            h = heuristic(neighbor, goal)\n            heapq.heappush(open_set, (h, neighbor, path))\n\n# Exemplo de uso\ngraph = {'A': ['B', 'C'], 'B': ['D'], 'C': ['E', 'F'], 'D': [], 'E': [], 'F': []}\nheuristic = lambda x, y: ord(y) - ord(x)\nstart = 'A'\ngoal = 'F'\nprint(best_first_search(graph, start, goal, heuristic))  # Output: ['A', 'C', 'F']\n</code></pre> <p>Mecanismo: Utiliza apenas a fun\u00e7\u00e3o heur\u00edstica (h(n)) para direcionar a busca.</p> <p>Filosofia: \"Expandir o n\u00f3 que parece mais pr\u00f3ximo do objetivo com base na heur\u00edstica.\"</p> <p>Completo: N\u00e3o necessariamente.</p> <p>\u00d3timo: N\u00e3o.</p> <p>Aplica\u00e7\u00f5es: Problemas em que encontrar uma solu\u00e7\u00e3o rapidamente \u00e9 mais importante do que encontrar a melhor solu\u00e7\u00e3o.</p>"},{"location":"search_algorithms/#hill-climbing","title":"Hill Climbing","text":"<pre><code>def hill_climbing(graph, start, goal, heuristic):\n    current = start\n    path = [current]\n\n    while current != goal:\n        neighbors = [(neighbor, heuristic(neighbor, goal)) for neighbor in graph[current]]\n        if not neighbors:\n            return None  # Falhou em encontrar um caminho\n\n        # Escolhe o vizinho com a melhor heur\u00edstica\n        best_neighbor, _ = min(neighbors, key=lambda x: x[1])\n\n        if heuristic(best_neighbor, goal) &gt;= heuristic(current, goal):\n            return None  # Alcan\u00e7ado um m\u00e1ximo local\n\n        current = best_neighbor\n        path.append(current)\n\n    return path\n\n# Exemplo de uso\ngraph = {'A': ['B', 'C'], 'B': ['D'], 'C': ['E', 'F'], 'D': [], 'E': [], 'F': []}\nheuristic = lambda x, y: ord(y) - ord(x)\nstart = 'A'\ngoal = 'F'\nprint(hill_climbing(graph, start, goal, heuristic))  # Output: ['A', 'C', 'F']\n</code></pre> <p>Mecanismo: Escolhe o melhor n\u00f3 vizinho com base na heur\u00edstica e move-se para ele, sem manter um hist\u00f3rico.</p> <p>Filosofia: \"Sempre suba a colina. Se chegar ao topo, pare.\"</p> <p>Completo: N\u00e3o.</p> <p>\u00d3timo: N\u00e3o.</p> <p>Aplica\u00e7\u00f5es: Otimiza\u00e7\u00e3o local, onde encontrar um m\u00e1ximo ou m\u00ednimo local \u00e9 suficiente.</p>"},{"location":"search_algorithms/#resumo-das-diferencas_1","title":"Resumo das Diferen\u00e7as","text":"<p>Heur\u00edsticas:</p> <ul> <li>A* usa tanto o custo real at\u00e9 o ponto atual (g(n)) quanto uma estimativa para o objetivo (h(n)).</li> <li>Best-First e Hill Climbing usam apenas a estimativa para o objetivo (h(n)).</li> </ul> <p>\u00d3timalidade:</p> <ul> <li>A* \u00e9 \u00f3timo se a heur\u00edstica for admiss\u00edvel e consistente.</li> <li>Best-First e Hill Climbing n\u00e3o garantem a \u00f3timalidade.</li> </ul> <p>Completude:</p> <ul> <li>A* \u00e9 completo, enquanto Best-First e Hill Climbing podem falhar em encontrar uma solu\u00e7\u00e3o.</li> </ul> <p>Uso de Mem\u00f3ria:</p> <ul> <li>A* e Best-First podem usar uma quantidade significativa de mem\u00f3ria para armazenar n\u00f3s.</li> <li>Hill Climbing usa pouca mem\u00f3ria, pois n\u00e3o mant\u00e9m um hist\u00f3rico de estados.</li> </ul> <p>Aplica\u00e7\u00f5es:</p> <ul> <li>A* \u00e9 geralmente preferido quando uma solu\u00e7\u00e3o \u00f3tima \u00e9 necess\u00e1ria.</li> <li>Best-First \u00e9 \u00fatil quando a velocidade \u00e9 mais importante do que a precis\u00e3o.</li> <li>Hill Climbing \u00e9 usado para otimiza\u00e7\u00f5es locais, onde o espa\u00e7o de estados \u00e9 muito grande para explorar completamente.</li> </ul> <p>Escolher o algoritmo certo depende fortemente do problema espec\u00edfico que voc\u00ea est\u00e1 tentando resolver, das garantias que voc\u00ea precisa (completude, \u00f3timalidade), e dos recursos dispon\u00edveis (tempo, mem\u00f3ria).</p>"},{"location":"search_algorithms/#consideracoes-gerais","title":"Considera\u00e7\u00f5es Gerais","text":""},{"location":"search_algorithms/#aplicabilidade","title":"Aplicabilidade:","text":"<p>A escolha do tipo de algoritmo de busca a ser utilizado depende muito do tipo  de problema. Buscas cegas s\u00e3o mais gen\u00e9ricas e f\u00e1ceis de implementar, mas podem ser impratic\u00e1veis para espa\u00e7os de estados muito grandes. Buscas informadas s\u00e3o  geralmente prefer\u00edveis quando se tem um bom conhecimento do dom\u00ednio do  problema.</p>"},{"location":"search_algorithms/#recursos-computacionais","title":"Recursos Computacionais:","text":"<p>Algoritmos de busca podem ser intensivos em termos de tempo e mem\u00f3ria, o que \u00e9  uma considera\u00e7\u00e3o importante em aplica\u00e7\u00f5es em tempo real ou em dispositivos com  recursos limitados.</p>"},{"location":"search_algorithms/#heuristicas","title":"Heur\u00edsticas:","text":"<p>Em buscas informadas, a sele\u00e7\u00e3o de uma boa heur\u00edstica \u00e9 crucial.  Uma heur\u00edstica inadequada pode fazer com que o algoritmo funcione mal,  enquanto uma boa heur\u00edstica pode resolver o problema de forma muito eficiente.</p> <p>Em resumo, algoritmos de busca s\u00e3o uma ferramenta fundamental em IA para a  resolu\u00e7\u00e3o de problemas, e a compreens\u00e3o dos diferentes tipos e suas  aplica\u00e7\u00f5es pode fornecer insights valiosos na escolha da estrat\u00e9gia de  resolu\u00e7\u00e3o de problemas mais adequada.</p> <p></p>"},{"location":"search_algorithms/#um-algoritmo-de-busca-nao-discutido-em-sala-de-aula","title":"Um algoritmo de busca n\u00e3o discutido em sala de aula","text":"<p>Ambos os algoritmos comentados abaixo s\u00e3o de busca cega.</p>"},{"location":"search_algorithms/#dijkstra","title":"Dijkstra","text":"<p>Um algoritmo relacionado aos mencionados acima \u00e9 o Dijkstra, que \u00e9 um algoritmo de busca de caminho mais curto. Ele \u00e9 um algoritmo de busca em grafos que serve  para encontrar o caminho mais curto entre um n\u00f3 inicial e todos os outros n\u00f3s  em um grafo ponderado e dirigido. Importante notar que os pesos das arestas devem ser n\u00e3o-negativos para que o algoritmo funcione corretamente.</p> <p>Vale lembrar que o algoritmo A* \u00e9 uma varia\u00e7\u00e3o do algoritmo de Dijkstra que usa heur\u00edsticas para encontrar o caminho mais curto. Ou seja, Dijkstra \u00e9 um A* sem heur\u00edsticas, ou seja, n\u00e3o informado sobre o ambiente.</p> <pre><code>import heapq\n\ndef dijkstra(graph, start, goal):\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    queue = [(0, start)]\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance &gt; distances[current_node]:\n            continue\n\n        if current_node == goal:\n            return current_distance\n\n        for neighbor, weight in graph[current_node].items():\n            distance = current_distance + weight\n\n            if distance &lt; distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n# Exemplo de uso\ngraph = {'A': {'B': 1, 'C': 4}, 'B': {'A': 1, 'D': 2}, 'C': {'A': 4, 'E': 3}, 'D': {'B': 2}, 'E': {'C': 3, 'F': 5}, 'F': {'E': 5}}\nprint(dijkstra(graph, 'A', 'F'))  # Output: 9\n</code></pre>"},{"location":"search_algorithms/#bellman-ford","title":"Bellman-Ford","text":"<p>Outro algoritmo parecido com Dijkstra que tamb\u00e9m vale mencionar \u00e9 o Bellman-Ford que tamb\u00e9m \u00e9 um algoritmo de busca de caminho mais curto, por\u00e9m ele funciona mesmo quando as arestas possuem pesos negativos. Por\u00e9m, ele \u00e9 mais lento que o Dijkstra.</p> <pre><code>def bellman_ford(graph, start, end):\n    distance = {node: float('inf') for node in graph}\n    distance[start] = 0\n\n    for _ in range(len(graph) - 1):\n        for node in graph:\n            for neighbour, cost in graph[node].items():\n                if distance[node] + cost &lt; distance[neighbour]:\n                    distance[neighbour] = distance[node] + cost\n\n    for node in graph:\n        for neighbour, cost in graph[node].items():\n            if distance[node] + cost &lt; distance[neighbour]:\n                print(\"Graph contains a negative weight cycle\")\n                return None\n\n    return distance[end]\n\n# Exemplo de uso\ngraph = {'A': {'B': -1, 'C':  4},\n         'B': {'C':  3, 'D':  2, 'E':  2},\n         'C': {},\n         'D': {'B':  1, 'C':  5},\n         'E': {'D': -3}}\nprint(bellman_ford(graph, 'A', 'E'))  # Output: 1 (seguindo o caminho A -&gt; B -&gt; E)\n</code></pre>"},{"location":"search_algorithms/#comparacao-entre-dijkstra-e-bellman-ford","title":"Compara\u00e7\u00e3o entre Dijkstra e Bellman-Ford:","text":"<ul> <li> <p>Dijkstra: Mais r\u00e1pido para grafos sem arestas negativas, mas falha na presen\u00e7a de pesos negativos.</p> </li> <li> <p>Bellman-Ford: Mais lento, mas mais vers\u00e1til, j\u00e1 que pode lidar com arestas negativas e detectar ciclos negativos.</p> </li> </ul>"},{"location":"search_algorithms/#bibliografia","title":"Bibliografia","text":"<p>https://edisciplinas.usp.br/pluginfile.php/4848799/mod_resource/content/3/2019-ProblemasComoBusca-BuscaCega.pdf</p> <p>https://www.ime.usp.br/~cris/mac5711/slides/aula14.pdf</p> <p>https://www.youtube.com/watch?v=788_MGOgNA4</p> <p>https://www.youtube.com/watch?v=3cuOA-mxaHg</p> <p>https://www.youtube.com/watch?v=DlE2C0TTxqk</p> <p>https://theory.stanford.edu/~amitp/GameProgramming/AStarComparison.html</p> <p>https://www.geeksforgeeks.org/what-are-the-differences-between-bellman-fords-and-dijkstras-algorithms/</p>"},{"location":"state-of-the-art/","title":"Estado da arte, Benef\u00edcios e Riscos","text":"<p>One Hundred Year Study on Artificial Intelligence (AI100) da universidade de Stanford, nos Estados Unidos: O estado da arte da Intelig\u00eancia Artificial (IA) ainda est\u00e1 envolto em muitas quest\u00f5es n\u00e3o resolvidas, assim como o debate sobre a natureza da consci\u00eancia humana.</p> <p></p> <p>Mesmo com avan\u00e7os significativos em \u00e1reas como aprendizado de m\u00e1quina e redes neurais profundas, ainda n\u00e3o chegamos a um consenso sobre o que realmente constitui uma \"intelig\u00eancia\" similar \u00e0 humana. Em termos de engenharia de software, isso apresenta desafios como a modularidade e a escalabilidade, especialmente quando se trata de implementar IA em sistemas cr\u00edticos.</p> <p>Al\u00e9m disso, a integra\u00e7\u00e3o de m\u00faltiplas fontes de dados e a utiliza\u00e7\u00e3o de algoritmos complexos para tomada de decis\u00e3o trazem quest\u00f5es sobre a \"caixa-preta\" de IA, ou seja, a dificuldade de interpretar como exatamente as decis\u00f5es s\u00e3o tomadas por modelos de aprendizado profundo. Isso \u00e9 um gargalo tanto em termos de debug como de \u00e9tica, onde a accountability e a transpar\u00eancia s\u00e3o cruciais. As novas abordagens em IA, como modelos generativos e m\u00e9todos de aprendizado por refor\u00e7o, est\u00e3o moldando o progresso futuro, mas ainda estamos longe de ter um framework unificado que possa ser considerado uma IA verdadeiramente inteligente e consciente.</p>"}]}